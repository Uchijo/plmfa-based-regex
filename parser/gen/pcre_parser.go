// Code generated from PCRE.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // PCRE

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type PCREParser struct {
	*antlr.BaseParser
}

var PCREParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func pcreParserInit() {
	staticData := &PCREParserStaticData
	staticData.LiteralNames = []string{
		"", "'\\'", "'$'", "'.'", "'['", "'^'", "'|'", "'?'", "'*'", "'+'",
		"'{'", "'}'", "'('", "')'", "']'", "'[:'", "':]'", "','", "'-'", "'_'",
		"'='", "'&'", "'<'", "'>'", "'''", "':'", "'#'", "'!'", "'A'", "'B'",
		"'C'", "'D'", "'E'", "'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'",
		"'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", "'S'", "'T'", "'U'", "'V'",
		"'W'", "'X'", "'Y'", "'Z'", "'a'", "'b'", "'c'", "'d'", "'e'", "'f'",
		"'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'",
		"'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'",
		"'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'",
	}
	staticData.SymbolicNames = []string{
		"", "BSlash", "Dollar", "Dot", "OBrack", "Caret", "Pipe", "QMark", "Star",
		"Plus", "OBrace", "CBrace", "OPar", "CPar", "CBrack", "OPosixBrack",
		"CPosixBrack", "Comma", "Dash", "UScore", "Eq", "Amp", "Lt", "Gt", "Quote",
		"Col", "Hash", "Excl", "Au", "Bu", "Cu", "Du", "Eu", "Fu", "Gu", "Hu",
		"Iu", "Ju", "Ku", "Lu", "Mu", "Nu", "Ou", "Pu", "Qu", "Ru", "Su", "Tu",
		"Uu", "Vu", "Wu", "Xu", "Yu", "Zu", "Al", "Bl", "Cl", "Dl", "El", "Fl",
		"Gl", "Hl", "Il", "Jl", "Kl", "Ll", "Ml", "Nl", "Ol", "Pl", "Ql", "Rl",
		"Sl", "Tl", "Ul", "Vl", "Wl", "Xl", "Yl", "Zl", "D0", "D1", "D2", "D3",
		"D4", "D5", "D6", "D7", "D8", "D9", "OTHER",
	}
	staticData.RuleNames = []string{
		"pcre", "alternation", "expr", "element", "atom", "capture", "atomic_group",
		"lookaround", "backreference", "subroutine_reference", "conditional_pattern",
		"comment", "quantifier", "option_setting", "option_setting_flag", "backtracking_control",
		"callout", "newline_conventions", "character", "character_type", "character_class",
		"character_class_atom", "character_class_range", "character_class_range_atom",
		"posix_character_class", "anchor", "match_point_reset", "quoting", "digits",
		"digit", "hex", "letters", "letter", "name", "other", "utf", "ucp",
		"no_auto_possess", "no_start_opt", "cr", "lf", "crlf", "anycrlf", "any",
		"limit_match", "limit_recursion", "bsr_anycrlf", "bsr_unicode", "accept_",
		"fail", "mark", "commit", "prune", "skip", "then",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 90, 834, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 1, 0, 3, 0, 112, 8, 0, 1, 0, 1, 0, 1, 1,
		1, 1, 1, 1, 3, 1, 119, 8, 1, 5, 1, 121, 8, 1, 10, 1, 12, 1, 124, 9, 1,
		1, 2, 4, 2, 127, 8, 2, 11, 2, 12, 2, 128, 1, 3, 1, 3, 3, 3, 133, 8, 3,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 155, 8, 4, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 4, 5, 177, 8, 5, 11, 5, 12, 5,
		178, 1, 5, 1, 5, 4, 5, 183, 8, 5, 11, 5, 12, 5, 184, 3, 5, 187, 8, 5, 3,
		5, 189, 8, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 195, 8, 5, 3, 5, 197, 8, 5,
		1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 215, 8, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 226, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 251, 8, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 260, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		266, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 274, 8, 9, 1, 9, 1,
		9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3,
		9, 289, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 296, 8, 9, 1, 9, 1, 9,
		1, 9, 3, 9, 301, 8, 9, 3, 9, 303, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 309, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 3, 10, 322, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 328, 8, 10, 1, 10, 1, 10, 1, 10, 3, 10, 333, 8, 10, 1, 10, 1, 10, 1,
		10, 3, 10, 338, 8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 4, 11,
		346, 8, 11, 11, 11, 12, 11, 347, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 3,
		12, 355, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 361, 8, 12, 3, 12, 363,
		8, 12, 1, 12, 1, 12, 1, 12, 3, 12, 368, 8, 12, 3, 12, 370, 8, 12, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 380, 8, 13, 1,
		13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 3, 13, 396, 8, 13, 1, 13, 1, 13, 4, 13, 400, 8, 13,
		11, 13, 12, 13, 401, 1, 13, 1, 13, 4, 13, 406, 8, 13, 11, 13, 12, 13, 407,
		3, 13, 410, 8, 13, 1, 13, 1, 13, 4, 13, 414, 8, 13, 11, 13, 12, 13, 415,
		3, 13, 418, 8, 13, 3, 13, 420, 8, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 431, 8, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 3, 15, 439, 8, 15, 1, 15, 1, 15, 1, 15, 3, 15, 444, 8,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 449, 8, 15, 3, 15, 451, 8, 15, 1, 15, 1,
		15, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 459, 8, 16, 1, 16, 1, 16, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 468, 8, 17, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 482,
		8, 18, 3, 18, 484, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 4, 18, 491,
		8, 18, 11, 18, 12, 18, 492, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 4, 18, 506, 8, 18, 11, 18, 12, 18, 507,
		1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 522, 8, 18, 3, 18, 524, 8, 18, 1, 19, 1, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 537, 8, 19,
		1, 19, 1, 19, 3, 19, 541, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
		19, 3, 19, 549, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 556, 8,
		19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 566,
		8, 19, 3, 19, 568, 8, 19, 1, 20, 1, 20, 3, 20, 572, 8, 20, 1, 20, 1, 20,
		5, 20, 576, 8, 20, 10, 20, 12, 20, 579, 9, 20, 1, 20, 1, 20, 1, 20, 3,
		20, 584, 8, 20, 1, 20, 4, 20, 587, 8, 20, 11, 20, 12, 20, 588, 1, 20, 1,
		20, 3, 20, 593, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21,
		3, 21, 602, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 610,
		8, 23, 1, 24, 1, 24, 3, 24, 614, 8, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1,
		25, 1, 25, 1, 25, 3, 25, 623, 8, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27,
		1, 27, 5, 27, 631, 8, 27, 10, 27, 12, 27, 634, 9, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 3, 27, 640, 8, 27, 1, 28, 4, 28, 643, 8, 28, 11, 28, 12, 28,
		644, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1,
		30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 662, 8, 30, 1, 31, 4, 31,
		665, 8, 31, 11, 31, 12, 31, 666, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 5,
		33, 674, 8, 33, 10, 33, 12, 33, 677, 9, 33, 1, 34, 1, 34, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1,
		48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 804, 8, 49, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 632, 0, 55, 0, 2, 4, 6, 8,
		10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
		46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
		82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 0, 10, 2,
		0, 9, 9, 18, 18, 1, 0, 13, 13, 1, 0, 7, 9, 6, 0, 37, 37, 48, 48, 62, 62,
		66, 66, 72, 72, 77, 77, 2, 0, 1, 1, 14, 14, 1, 0, 14, 14, 5, 0, 28, 29,
		34, 34, 53, 53, 55, 55, 79, 79, 1, 0, 80, 89, 2, 0, 19, 19, 28, 79, 4,
		0, 11, 11, 14, 14, 17, 27, 90, 90, 951, 0, 111, 1, 0, 0, 0, 2, 115, 1,
		0, 0, 0, 4, 126, 1, 0, 0, 0, 6, 130, 1, 0, 0, 0, 8, 154, 1, 0, 0, 0, 10,
		156, 1, 0, 0, 0, 12, 200, 1, 0, 0, 0, 14, 206, 1, 0, 0, 0, 16, 259, 1,
		0, 0, 0, 18, 302, 1, 0, 0, 0, 20, 304, 1, 0, 0, 0, 22, 341, 1, 0, 0, 0,
		24, 369, 1, 0, 0, 0, 26, 371, 1, 0, 0, 0, 28, 423, 1, 0, 0, 0, 30, 425,
		1, 0, 0, 0, 32, 454, 1, 0, 0, 0, 34, 467, 1, 0, 0, 0, 36, 469, 1, 0, 0,
		0, 38, 567, 1, 0, 0, 0, 40, 592, 1, 0, 0, 0, 42, 601, 1, 0, 0, 0, 44, 603,
		1, 0, 0, 0, 46, 609, 1, 0, 0, 0, 48, 611, 1, 0, 0, 0, 50, 622, 1, 0, 0,
		0, 52, 624, 1, 0, 0, 0, 54, 639, 1, 0, 0, 0, 56, 642, 1, 0, 0, 0, 58, 646,
		1, 0, 0, 0, 60, 661, 1, 0, 0, 0, 62, 664, 1, 0, 0, 0, 64, 668, 1, 0, 0,
		0, 66, 670, 1, 0, 0, 0, 68, 678, 1, 0, 0, 0, 70, 680, 1, 0, 0, 0, 72, 684,
		1, 0, 0, 0, 74, 688, 1, 0, 0, 0, 76, 704, 1, 0, 0, 0, 78, 717, 1, 0, 0,
		0, 80, 720, 1, 0, 0, 0, 82, 723, 1, 0, 0, 0, 84, 728, 1, 0, 0, 0, 86, 736,
		1, 0, 0, 0, 88, 740, 1, 0, 0, 0, 90, 752, 1, 0, 0, 0, 92, 768, 1, 0, 0,
		0, 94, 780, 1, 0, 0, 0, 96, 792, 1, 0, 0, 0, 98, 799, 1, 0, 0, 0, 100,
		805, 1, 0, 0, 0, 102, 810, 1, 0, 0, 0, 104, 817, 1, 0, 0, 0, 106, 823,
		1, 0, 0, 0, 108, 828, 1, 0, 0, 0, 110, 112, 3, 2, 1, 0, 111, 110, 1, 0,
		0, 0, 111, 112, 1, 0, 0, 0, 112, 113, 1, 0, 0, 0, 113, 114, 5, 0, 0, 1,
		114, 1, 1, 0, 0, 0, 115, 122, 3, 4, 2, 0, 116, 118, 5, 6, 0, 0, 117, 119,
		3, 4, 2, 0, 118, 117, 1, 0, 0, 0, 118, 119, 1, 0, 0, 0, 119, 121, 1, 0,
		0, 0, 120, 116, 1, 0, 0, 0, 121, 124, 1, 0, 0, 0, 122, 120, 1, 0, 0, 0,
		122, 123, 1, 0, 0, 0, 123, 3, 1, 0, 0, 0, 124, 122, 1, 0, 0, 0, 125, 127,
		3, 6, 3, 0, 126, 125, 1, 0, 0, 0, 127, 128, 1, 0, 0, 0, 128, 126, 1, 0,
		0, 0, 128, 129, 1, 0, 0, 0, 129, 5, 1, 0, 0, 0, 130, 132, 3, 8, 4, 0, 131,
		133, 3, 24, 12, 0, 132, 131, 1, 0, 0, 0, 132, 133, 1, 0, 0, 0, 133, 7,
		1, 0, 0, 0, 134, 155, 3, 26, 13, 0, 135, 155, 3, 30, 15, 0, 136, 155, 3,
		32, 16, 0, 137, 155, 3, 10, 5, 0, 138, 155, 3, 12, 6, 0, 139, 155, 3, 14,
		7, 0, 140, 155, 3, 16, 8, 0, 141, 155, 3, 18, 9, 0, 142, 155, 3, 20, 10,
		0, 143, 155, 3, 22, 11, 0, 144, 155, 3, 36, 18, 0, 145, 155, 3, 38, 19,
		0, 146, 155, 3, 40, 20, 0, 147, 155, 3, 48, 24, 0, 148, 155, 3, 64, 32,
		0, 149, 155, 3, 58, 29, 0, 150, 155, 3, 50, 25, 0, 151, 155, 3, 52, 26,
		0, 152, 155, 3, 54, 27, 0, 153, 155, 3, 68, 34, 0, 154, 134, 1, 0, 0, 0,
		154, 135, 1, 0, 0, 0, 154, 136, 1, 0, 0, 0, 154, 137, 1, 0, 0, 0, 154,
		138, 1, 0, 0, 0, 154, 139, 1, 0, 0, 0, 154, 140, 1, 0, 0, 0, 154, 141,
		1, 0, 0, 0, 154, 142, 1, 0, 0, 0, 154, 143, 1, 0, 0, 0, 154, 144, 1, 0,
		0, 0, 154, 145, 1, 0, 0, 0, 154, 146, 1, 0, 0, 0, 154, 147, 1, 0, 0, 0,
		154, 148, 1, 0, 0, 0, 154, 149, 1, 0, 0, 0, 154, 150, 1, 0, 0, 0, 154,
		151, 1, 0, 0, 0, 154, 152, 1, 0, 0, 0, 154, 153, 1, 0, 0, 0, 155, 9, 1,
		0, 0, 0, 156, 196, 5, 12, 0, 0, 157, 197, 3, 2, 1, 0, 158, 194, 5, 7, 0,
		0, 159, 160, 5, 22, 0, 0, 160, 161, 3, 66, 33, 0, 161, 162, 5, 23, 0, 0,
		162, 163, 3, 2, 1, 0, 163, 195, 1, 0, 0, 0, 164, 165, 5, 24, 0, 0, 165,
		166, 3, 66, 33, 0, 166, 167, 5, 24, 0, 0, 167, 168, 3, 2, 1, 0, 168, 195,
		1, 0, 0, 0, 169, 170, 5, 43, 0, 0, 170, 171, 5, 22, 0, 0, 171, 172, 3,
		66, 33, 0, 172, 173, 5, 23, 0, 0, 173, 174, 3, 2, 1, 0, 174, 195, 1, 0,
		0, 0, 175, 177, 3, 28, 14, 0, 176, 175, 1, 0, 0, 0, 177, 178, 1, 0, 0,
		0, 178, 176, 1, 0, 0, 0, 178, 179, 1, 0, 0, 0, 179, 186, 1, 0, 0, 0, 180,
		182, 5, 18, 0, 0, 181, 183, 3, 28, 14, 0, 182, 181, 1, 0, 0, 0, 183, 184,
		1, 0, 0, 0, 184, 182, 1, 0, 0, 0, 184, 185, 1, 0, 0, 0, 185, 187, 1, 0,
		0, 0, 186, 180, 1, 0, 0, 0, 186, 187, 1, 0, 0, 0, 187, 189, 1, 0, 0, 0,
		188, 176, 1, 0, 0, 0, 188, 189, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190,
		191, 5, 25, 0, 0, 191, 195, 3, 2, 1, 0, 192, 193, 5, 6, 0, 0, 193, 195,
		3, 2, 1, 0, 194, 159, 1, 0, 0, 0, 194, 164, 1, 0, 0, 0, 194, 169, 1, 0,
		0, 0, 194, 188, 1, 0, 0, 0, 194, 192, 1, 0, 0, 0, 195, 197, 1, 0, 0, 0,
		196, 157, 1, 0, 0, 0, 196, 158, 1, 0, 0, 0, 197, 198, 1, 0, 0, 0, 198,
		199, 5, 13, 0, 0, 199, 11, 1, 0, 0, 0, 200, 201, 5, 12, 0, 0, 201, 202,
		5, 7, 0, 0, 202, 203, 5, 23, 0, 0, 203, 204, 3, 2, 1, 0, 204, 205, 5, 13,
		0, 0, 205, 13, 1, 0, 0, 0, 206, 207, 5, 12, 0, 0, 207, 214, 5, 7, 0, 0,
		208, 215, 5, 20, 0, 0, 209, 215, 5, 27, 0, 0, 210, 211, 5, 22, 0, 0, 211,
		215, 5, 20, 0, 0, 212, 213, 5, 22, 0, 0, 213, 215, 5, 27, 0, 0, 214, 208,
		1, 0, 0, 0, 214, 209, 1, 0, 0, 0, 214, 210, 1, 0, 0, 0, 214, 212, 1, 0,
		0, 0, 215, 216, 1, 0, 0, 0, 216, 217, 3, 2, 1, 0, 217, 218, 5, 13, 0, 0,
		218, 15, 1, 0, 0, 0, 219, 250, 5, 1, 0, 0, 220, 221, 5, 60, 0, 0, 221,
		251, 3, 56, 28, 0, 222, 223, 5, 60, 0, 0, 223, 225, 5, 10, 0, 0, 224, 226,
		5, 18, 0, 0, 225, 224, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 227, 1, 0,
		0, 0, 227, 228, 3, 56, 28, 0, 228, 229, 5, 11, 0, 0, 229, 251, 1, 0, 0,
		0, 230, 231, 5, 60, 0, 0, 231, 232, 5, 10, 0, 0, 232, 233, 3, 66, 33, 0,
		233, 234, 5, 11, 0, 0, 234, 251, 1, 0, 0, 0, 235, 236, 5, 64, 0, 0, 236,
		237, 5, 22, 0, 0, 237, 238, 3, 66, 33, 0, 238, 239, 5, 23, 0, 0, 239, 251,
		1, 0, 0, 0, 240, 241, 5, 64, 0, 0, 241, 242, 5, 24, 0, 0, 242, 243, 3,
		66, 33, 0, 243, 244, 5, 24, 0, 0, 244, 251, 1, 0, 0, 0, 245, 246, 5, 64,
		0, 0, 246, 247, 5, 10, 0, 0, 247, 248, 3, 66, 33, 0, 248, 249, 5, 11, 0,
		0, 249, 251, 1, 0, 0, 0, 250, 220, 1, 0, 0, 0, 250, 222, 1, 0, 0, 0, 250,
		230, 1, 0, 0, 0, 250, 235, 1, 0, 0, 0, 250, 240, 1, 0, 0, 0, 250, 245,
		1, 0, 0, 0, 251, 260, 1, 0, 0, 0, 252, 253, 5, 12, 0, 0, 253, 254, 5, 7,
		0, 0, 254, 255, 5, 43, 0, 0, 255, 256, 5, 20, 0, 0, 256, 257, 3, 66, 33,
		0, 257, 258, 5, 13, 0, 0, 258, 260, 1, 0, 0, 0, 259, 219, 1, 0, 0, 0, 259,
		252, 1, 0, 0, 0, 260, 17, 1, 0, 0, 0, 261, 262, 5, 12, 0, 0, 262, 273,
		5, 7, 0, 0, 263, 274, 5, 45, 0, 0, 264, 266, 7, 0, 0, 0, 265, 264, 1, 0,
		0, 0, 265, 266, 1, 0, 0, 0, 266, 267, 1, 0, 0, 0, 267, 274, 3, 56, 28,
		0, 268, 269, 5, 21, 0, 0, 269, 274, 3, 66, 33, 0, 270, 271, 5, 43, 0, 0,
		271, 272, 5, 23, 0, 0, 272, 274, 3, 66, 33, 0, 273, 263, 1, 0, 0, 0, 273,
		265, 1, 0, 0, 0, 273, 268, 1, 0, 0, 0, 273, 270, 1, 0, 0, 0, 274, 275,
		1, 0, 0, 0, 275, 303, 5, 13, 0, 0, 276, 277, 5, 1, 0, 0, 277, 300, 5, 60,
		0, 0, 278, 279, 5, 22, 0, 0, 279, 280, 3, 66, 33, 0, 280, 281, 5, 23, 0,
		0, 281, 301, 1, 0, 0, 0, 282, 283, 5, 24, 0, 0, 283, 284, 3, 66, 33, 0,
		284, 285, 5, 24, 0, 0, 285, 301, 1, 0, 0, 0, 286, 288, 5, 22, 0, 0, 287,
		289, 7, 0, 0, 0, 288, 287, 1, 0, 0, 0, 288, 289, 1, 0, 0, 0, 289, 290,
		1, 0, 0, 0, 290, 291, 3, 56, 28, 0, 291, 292, 5, 23, 0, 0, 292, 301, 1,
		0, 0, 0, 293, 295, 5, 24, 0, 0, 294, 296, 7, 0, 0, 0, 295, 294, 1, 0, 0,
		0, 295, 296, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297, 298, 3, 56, 28, 0,
		298, 299, 5, 24, 0, 0, 299, 301, 1, 0, 0, 0, 300, 278, 1, 0, 0, 0, 300,
		282, 1, 0, 0, 0, 300, 286, 1, 0, 0, 0, 300, 293, 1, 0, 0, 0, 301, 303,
		1, 0, 0, 0, 302, 261, 1, 0, 0, 0, 302, 276, 1, 0, 0, 0, 303, 19, 1, 0,
		0, 0, 304, 305, 5, 12, 0, 0, 305, 332, 5, 7, 0, 0, 306, 327, 5, 12, 0,
		0, 307, 309, 7, 0, 0, 0, 308, 307, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0, 309,
		310, 1, 0, 0, 0, 310, 328, 3, 56, 28, 0, 311, 312, 5, 22, 0, 0, 312, 313,
		3, 66, 33, 0, 313, 314, 5, 23, 0, 0, 314, 328, 1, 0, 0, 0, 315, 316, 5,
		24, 0, 0, 316, 317, 3, 66, 33, 0, 317, 318, 5, 24, 0, 0, 318, 328, 1, 0,
		0, 0, 319, 321, 5, 45, 0, 0, 320, 322, 3, 56, 28, 0, 321, 320, 1, 0, 0,
		0, 321, 322, 1, 0, 0, 0, 322, 328, 1, 0, 0, 0, 323, 324, 5, 45, 0, 0, 324,
		325, 5, 21, 0, 0, 325, 328, 3, 66, 33, 0, 326, 328, 3, 66, 33, 0, 327,
		308, 1, 0, 0, 0, 327, 311, 1, 0, 0, 0, 327, 315, 1, 0, 0, 0, 327, 319,
		1, 0, 0, 0, 327, 323, 1, 0, 0, 0, 327, 326, 1, 0, 0, 0, 328, 329, 1, 0,
		0, 0, 329, 333, 5, 13, 0, 0, 330, 333, 3, 32, 16, 0, 331, 333, 3, 14, 7,
		0, 332, 306, 1, 0, 0, 0, 332, 330, 1, 0, 0, 0, 332, 331, 1, 0, 0, 0, 333,
		334, 1, 0, 0, 0, 334, 337, 3, 4, 2, 0, 335, 336, 5, 6, 0, 0, 336, 338,
		3, 4, 2, 0, 337, 335, 1, 0, 0, 0, 337, 338, 1, 0, 0, 0, 338, 339, 1, 0,
		0, 0, 339, 340, 5, 13, 0, 0, 340, 21, 1, 0, 0, 0, 341, 342, 5, 12, 0, 0,
		342, 343, 5, 7, 0, 0, 343, 345, 5, 26, 0, 0, 344, 346, 8, 1, 0, 0, 345,
		344, 1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 347, 348,
		1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349, 350, 5, 13, 0, 0, 350, 23, 1, 0,
		0, 0, 351, 354, 7, 2, 0, 0, 352, 355, 5, 9, 0, 0, 353, 355, 5, 7, 0, 0,
		354, 352, 1, 0, 0, 0, 354, 353, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355,
		370, 1, 0, 0, 0, 356, 357, 5, 10, 0, 0, 357, 362, 3, 56, 28, 0, 358, 360,
		5, 17, 0, 0, 359, 361, 3, 56, 28, 0, 360, 359, 1, 0, 0, 0, 360, 361, 1,
		0, 0, 0, 361, 363, 1, 0, 0, 0, 362, 358, 1, 0, 0, 0, 362, 363, 1, 0, 0,
		0, 363, 364, 1, 0, 0, 0, 364, 367, 5, 11, 0, 0, 365, 368, 5, 9, 0, 0, 366,
		368, 5, 7, 0, 0, 367, 365, 1, 0, 0, 0, 367, 366, 1, 0, 0, 0, 367, 368,
		1, 0, 0, 0, 368, 370, 1, 0, 0, 0, 369, 351, 1, 0, 0, 0, 369, 356, 1, 0,
		0, 0, 370, 25, 1, 0, 0, 0, 371, 419, 5, 12, 0, 0, 372, 395, 5, 8, 0, 0,
		373, 379, 3, 70, 35, 0, 374, 380, 5, 88, 0, 0, 375, 376, 5, 81, 0, 0, 376,
		380, 5, 86, 0, 0, 377, 378, 5, 83, 0, 0, 378, 380, 5, 82, 0, 0, 379, 374,
		1, 0, 0, 0, 379, 375, 1, 0, 0, 0, 379, 377, 1, 0, 0, 0, 379, 380, 1, 0,
		0, 0, 380, 396, 1, 0, 0, 0, 381, 396, 3, 72, 36, 0, 382, 396, 3, 74, 37,
		0, 383, 396, 3, 76, 38, 0, 384, 396, 3, 34, 17, 0, 385, 386, 3, 88, 44,
		0, 386, 387, 5, 20, 0, 0, 387, 388, 3, 56, 28, 0, 388, 396, 1, 0, 0, 0,
		389, 390, 3, 90, 45, 0, 390, 391, 5, 20, 0, 0, 391, 392, 3, 56, 28, 0,
		392, 396, 1, 0, 0, 0, 393, 396, 3, 92, 46, 0, 394, 396, 3, 94, 47, 0, 395,
		373, 1, 0, 0, 0, 395, 381, 1, 0, 0, 0, 395, 382, 1, 0, 0, 0, 395, 383,
		1, 0, 0, 0, 395, 384, 1, 0, 0, 0, 395, 385, 1, 0, 0, 0, 395, 389, 1, 0,
		0, 0, 395, 393, 1, 0, 0, 0, 395, 394, 1, 0, 0, 0, 396, 420, 1, 0, 0, 0,
		397, 417, 5, 7, 0, 0, 398, 400, 3, 28, 14, 0, 399, 398, 1, 0, 0, 0, 400,
		401, 1, 0, 0, 0, 401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 409,
		1, 0, 0, 0, 403, 405, 5, 18, 0, 0, 404, 406, 3, 28, 14, 0, 405, 404, 1,
		0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 407, 408, 1, 0, 0,
		0, 408, 410, 1, 0, 0, 0, 409, 403, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410,
		418, 1, 0, 0, 0, 411, 413, 5, 18, 0, 0, 412, 414, 3, 28, 14, 0, 413, 412,
		1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415, 413, 1, 0, 0, 0, 415, 416, 1, 0,
		0, 0, 416, 418, 1, 0, 0, 0, 417, 399, 1, 0, 0, 0, 417, 411, 1, 0, 0, 0,
		418, 420, 1, 0, 0, 0, 419, 372, 1, 0, 0, 0, 419, 397, 1, 0, 0, 0, 420,
		421, 1, 0, 0, 0, 421, 422, 5, 13, 0, 0, 422, 27, 1, 0, 0, 0, 423, 424,
		7, 3, 0, 0, 424, 29, 1, 0, 0, 0, 425, 426, 5, 12, 0, 0, 426, 450, 5, 8,
		0, 0, 427, 451, 3, 96, 48, 0, 428, 451, 3, 98, 49, 0, 429, 431, 3, 100,
		50, 0, 430, 429, 1, 0, 0, 0, 430, 431, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0,
		432, 433, 5, 25, 0, 0, 433, 451, 3, 66, 33, 0, 434, 451, 3, 102, 51, 0,
		435, 438, 3, 104, 52, 0, 436, 437, 5, 25, 0, 0, 437, 439, 3, 66, 33, 0,
		438, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 451, 1, 0, 0, 0, 440,
		443, 3, 106, 53, 0, 441, 442, 5, 25, 0, 0, 442, 444, 3, 66, 33, 0, 443,
		441, 1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 451, 1, 0, 0, 0, 445, 448,
		3, 108, 54, 0, 446, 447, 5, 25, 0, 0, 447, 449, 3, 66, 33, 0, 448, 446,
		1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 451, 1, 0, 0, 0, 450, 427, 1, 0,
		0, 0, 450, 428, 1, 0, 0, 0, 450, 430, 1, 0, 0, 0, 450, 434, 1, 0, 0, 0,
		450, 435, 1, 0, 0, 0, 450, 440, 1, 0, 0, 0, 450, 445, 1, 0, 0, 0, 451,
		452, 1, 0, 0, 0, 452, 453, 5, 13, 0, 0, 453, 31, 1, 0, 0, 0, 454, 455,
		5, 12, 0, 0, 455, 456, 5, 7, 0, 0, 456, 458, 5, 30, 0, 0, 457, 459, 3,
		56, 28, 0, 458, 457, 1, 0, 0, 0, 458, 459, 1, 0, 0, 0, 459, 460, 1, 0,
		0, 0, 460, 461, 5, 13, 0, 0, 461, 33, 1, 0, 0, 0, 462, 468, 3, 78, 39,
		0, 463, 468, 3, 80, 40, 0, 464, 468, 3, 82, 41, 0, 465, 468, 3, 84, 42,
		0, 466, 468, 3, 86, 43, 0, 467, 462, 1, 0, 0, 0, 467, 463, 1, 0, 0, 0,
		467, 464, 1, 0, 0, 0, 467, 465, 1, 0, 0, 0, 467, 466, 1, 0, 0, 0, 468,
		35, 1, 0, 0, 0, 469, 523, 5, 1, 0, 0, 470, 524, 5, 54, 0, 0, 471, 472,
		5, 56, 0, 0, 472, 524, 9, 0, 0, 0, 473, 524, 5, 58, 0, 0, 474, 524, 5,
		59, 0, 0, 475, 524, 5, 67, 0, 0, 476, 524, 5, 71, 0, 0, 477, 524, 5, 73,
		0, 0, 478, 483, 3, 58, 29, 0, 479, 481, 3, 58, 29, 0, 480, 482, 3, 58,
		29, 0, 481, 480, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 484, 1, 0, 0, 0,
		483, 479, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 524, 1, 0, 0, 0, 485,
		486, 5, 68, 0, 0, 486, 487, 5, 10, 0, 0, 487, 488, 3, 58, 29, 0, 488, 490,
		3, 58, 29, 0, 489, 491, 3, 58, 29, 0, 490, 489, 1, 0, 0, 0, 491, 492, 1,
		0, 0, 0, 492, 490, 1, 0, 0, 0, 492, 493, 1, 0, 0, 0, 493, 494, 1, 0, 0,
		0, 494, 495, 5, 11, 0, 0, 495, 524, 1, 0, 0, 0, 496, 497, 5, 77, 0, 0,
		497, 498, 3, 60, 30, 0, 498, 499, 3, 60, 30, 0, 499, 524, 1, 0, 0, 0, 500,
		501, 5, 77, 0, 0, 501, 502, 5, 10, 0, 0, 502, 503, 3, 60, 30, 0, 503, 505,
		3, 60, 30, 0, 504, 506, 3, 60, 30, 0, 505, 504, 1, 0, 0, 0, 506, 507, 1,
		0, 0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 509, 1, 0, 0,
		0, 509, 510, 5, 11, 0, 0, 510, 524, 1, 0, 0, 0, 511, 512, 5, 74, 0, 0,
		512, 513, 3, 60, 30, 0, 513, 514, 3, 60, 30, 0, 514, 515, 3, 60, 30, 0,
		515, 521, 3, 60, 30, 0, 516, 517, 3, 60, 30, 0, 517, 518, 3, 60, 30, 0,
		518, 519, 3, 60, 30, 0, 519, 520, 3, 60, 30, 0, 520, 522, 1, 0, 0, 0, 521,
		516, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 524, 1, 0, 0, 0, 523, 470,
		1, 0, 0, 0, 523, 471, 1, 0, 0, 0, 523, 473, 1, 0, 0, 0, 523, 474, 1, 0,
		0, 0, 523, 475, 1, 0, 0, 0, 523, 476, 1, 0, 0, 0, 523, 477, 1, 0, 0, 0,
		523, 478, 1, 0, 0, 0, 523, 485, 1, 0, 0, 0, 523, 496, 1, 0, 0, 0, 523,
		500, 1, 0, 0, 0, 523, 511, 1, 0, 0, 0, 524, 37, 1, 0, 0, 0, 525, 568, 5,
		3, 0, 0, 526, 565, 5, 1, 0, 0, 527, 566, 5, 30, 0, 0, 528, 566, 5, 57,
		0, 0, 529, 566, 5, 31, 0, 0, 530, 566, 5, 61, 0, 0, 531, 566, 5, 35, 0,
		0, 532, 566, 5, 41, 0, 0, 533, 534, 5, 69, 0, 0, 534, 536, 5, 10, 0, 0,
		535, 537, 5, 5, 0, 0, 536, 535, 1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537,
		538, 1, 0, 0, 0, 538, 540, 3, 66, 33, 0, 539, 541, 5, 21, 0, 0, 540, 539,
		1, 0, 0, 0, 540, 541, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 543, 5, 11,
		0, 0, 543, 566, 1, 0, 0, 0, 544, 545, 5, 43, 0, 0, 545, 546, 5, 10, 0,
		0, 546, 548, 3, 66, 33, 0, 547, 549, 5, 21, 0, 0, 548, 547, 1, 0, 0, 0,
		548, 549, 1, 0, 0, 0, 549, 550, 1, 0, 0, 0, 550, 551, 5, 11, 0, 0, 551,
		566, 1, 0, 0, 0, 552, 553, 5, 69, 0, 0, 553, 555, 3, 64, 32, 0, 554, 556,
		3, 64, 32, 0, 555, 554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 566, 1,
		0, 0, 0, 557, 566, 5, 45, 0, 0, 558, 566, 5, 72, 0, 0, 559, 566, 5, 46,
		0, 0, 560, 566, 5, 75, 0, 0, 561, 566, 5, 49, 0, 0, 562, 566, 5, 76, 0,
		0, 563, 566, 5, 50, 0, 0, 564, 566, 5, 51, 0, 0, 565, 527, 1, 0, 0, 0,
		565, 528, 1, 0, 0, 0, 565, 529, 1, 0, 0, 0, 565, 530, 1, 0, 0, 0, 565,
		531, 1, 0, 0, 0, 565, 532, 1, 0, 0, 0, 565, 533, 1, 0, 0, 0, 565, 544,
		1, 0, 0, 0, 565, 552, 1, 0, 0, 0, 565, 557, 1, 0, 0, 0, 565, 558, 1, 0,
		0, 0, 565, 559, 1, 0, 0, 0, 565, 560, 1, 0, 0, 0, 565, 561, 1, 0, 0, 0,
		565, 562, 1, 0, 0, 0, 565, 563, 1, 0, 0, 0, 565, 564, 1, 0, 0, 0, 566,
		568, 1, 0, 0, 0, 567, 525, 1, 0, 0, 0, 567, 526, 1, 0, 0, 0, 568, 39, 1,
		0, 0, 0, 569, 571, 5, 4, 0, 0, 570, 572, 5, 5, 0, 0, 571, 570, 1, 0, 0,
		0, 571, 572, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 577, 5, 14, 0, 0, 574,
		576, 3, 42, 21, 0, 575, 574, 1, 0, 0, 0, 576, 579, 1, 0, 0, 0, 577, 575,
		1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 580, 1, 0, 0, 0, 579, 577, 1, 0,
		0, 0, 580, 593, 5, 14, 0, 0, 581, 583, 5, 4, 0, 0, 582, 584, 5, 5, 0, 0,
		583, 582, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 586, 1, 0, 0, 0, 585,
		587, 3, 42, 21, 0, 586, 585, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 586,
		1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 5, 14,
		0, 0, 591, 593, 1, 0, 0, 0, 592, 569, 1, 0, 0, 0, 592, 581, 1, 0, 0, 0,
		593, 41, 1, 0, 0, 0, 594, 602, 3, 44, 22, 0, 595, 602, 3, 48, 24, 0, 596,
		602, 3, 36, 18, 0, 597, 602, 3, 38, 19, 0, 598, 599, 5, 1, 0, 0, 599, 602,
		9, 0, 0, 0, 600, 602, 8, 4, 0, 0, 601, 594, 1, 0, 0, 0, 601, 595, 1, 0,
		0, 0, 601, 596, 1, 0, 0, 0, 601, 597, 1, 0, 0, 0, 601, 598, 1, 0, 0, 0,
		601, 600, 1, 0, 0, 0, 602, 43, 1, 0, 0, 0, 603, 604, 3, 46, 23, 0, 604,
		605, 5, 18, 0, 0, 605, 606, 3, 46, 23, 0, 606, 45, 1, 0, 0, 0, 607, 610,
		3, 36, 18, 0, 608, 610, 8, 5, 0, 0, 609, 607, 1, 0, 0, 0, 609, 608, 1,
		0, 0, 0, 610, 47, 1, 0, 0, 0, 611, 613, 5, 15, 0, 0, 612, 614, 5, 5, 0,
		0, 613, 612, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615,
		616, 3, 62, 31, 0, 616, 617, 5, 16, 0, 0, 617, 49, 1, 0, 0, 0, 618, 619,
		5, 1, 0, 0, 619, 623, 7, 6, 0, 0, 620, 623, 5, 5, 0, 0, 621, 623, 5, 2,
		0, 0, 622, 618, 1, 0, 0, 0, 622, 620, 1, 0, 0, 0, 622, 621, 1, 0, 0, 0,
		623, 51, 1, 0, 0, 0, 624, 625, 5, 1, 0, 0, 625, 626, 5, 38, 0, 0, 626,
		53, 1, 0, 0, 0, 627, 628, 5, 1, 0, 0, 628, 632, 5, 44, 0, 0, 629, 631,
		9, 0, 0, 0, 630, 629, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 633, 1, 0,
		0, 0, 632, 630, 1, 0, 0, 0, 633, 635, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0,
		635, 636, 5, 1, 0, 0, 636, 640, 5, 32, 0, 0, 637, 638, 5, 1, 0, 0, 638,
		640, 9, 0, 0, 0, 639, 627, 1, 0, 0, 0, 639, 637, 1, 0, 0, 0, 640, 55, 1,
		0, 0, 0, 641, 643, 3, 58, 29, 0, 642, 641, 1, 0, 0, 0, 643, 644, 1, 0,
		0, 0, 644, 642, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 57, 1, 0, 0, 0,
		646, 647, 7, 7, 0, 0, 647, 59, 1, 0, 0, 0, 648, 662, 3, 58, 29, 0, 649,
		662, 5, 54, 0, 0, 650, 662, 5, 55, 0, 0, 651, 662, 5, 56, 0, 0, 652, 662,
		5, 57, 0, 0, 653, 662, 5, 58, 0, 0, 654, 662, 5, 59, 0, 0, 655, 662, 5,
		28, 0, 0, 656, 662, 5, 29, 0, 0, 657, 662, 5, 30, 0, 0, 658, 662, 5, 31,
		0, 0, 659, 662, 5, 32, 0, 0, 660, 662, 5, 33, 0, 0, 661, 648, 1, 0, 0,
		0, 661, 649, 1, 0, 0, 0, 661, 650, 1, 0, 0, 0, 661, 651, 1, 0, 0, 0, 661,
		652, 1, 0, 0, 0, 661, 653, 1, 0, 0, 0, 661, 654, 1, 0, 0, 0, 661, 655,
		1, 0, 0, 0, 661, 656, 1, 0, 0, 0, 661, 657, 1, 0, 0, 0, 661, 658, 1, 0,
		0, 0, 661, 659, 1, 0, 0, 0, 661, 660, 1, 0, 0, 0, 662, 61, 1, 0, 0, 0,
		663, 665, 3, 64, 32, 0, 664, 663, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666,
		664, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 63, 1, 0, 0, 0, 668, 669, 7,
		8, 0, 0, 669, 65, 1, 0, 0, 0, 670, 675, 3, 64, 32, 0, 671, 674, 3, 64,
		32, 0, 672, 674, 3, 58, 29, 0, 673, 671, 1, 0, 0, 0, 673, 672, 1, 0, 0,
		0, 674, 677, 1, 0, 0, 0, 675, 673, 1, 0, 0, 0, 675, 676, 1, 0, 0, 0, 676,
		67, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0, 678, 679, 7, 9, 0, 0, 679, 69, 1,
		0, 0, 0, 680, 681, 5, 48, 0, 0, 681, 682, 5, 47, 0, 0, 682, 683, 5, 33,
		0, 0, 683, 71, 1, 0, 0, 0, 684, 685, 5, 48, 0, 0, 685, 686, 5, 30, 0, 0,
		686, 687, 5, 43, 0, 0, 687, 73, 1, 0, 0, 0, 688, 689, 5, 41, 0, 0, 689,
		690, 5, 42, 0, 0, 690, 691, 5, 19, 0, 0, 691, 692, 5, 28, 0, 0, 692, 693,
		5, 48, 0, 0, 693, 694, 5, 47, 0, 0, 694, 695, 5, 42, 0, 0, 695, 696, 5,
		19, 0, 0, 696, 697, 5, 43, 0, 0, 697, 698, 5, 42, 0, 0, 698, 699, 5, 46,
		0, 0, 699, 700, 5, 46, 0, 0, 700, 701, 5, 32, 0, 0, 701, 702, 5, 46, 0,
		0, 702, 703, 5, 46, 0, 0, 703, 75, 1, 0, 0, 0, 704, 705, 5, 41, 0, 0, 705,
		706, 5, 42, 0, 0, 706, 707, 5, 19, 0, 0, 707, 708, 5, 46, 0, 0, 708, 709,
		5, 47, 0, 0, 709, 710, 5, 28, 0, 0, 710, 711, 5, 45, 0, 0, 711, 712, 5,
		47, 0, 0, 712, 713, 5, 19, 0, 0, 713, 714, 5, 42, 0, 0, 714, 715, 5, 43,
		0, 0, 715, 716, 5, 47, 0, 0, 716, 77, 1, 0, 0, 0, 717, 718, 5, 30, 0, 0,
		718, 719, 5, 45, 0, 0, 719, 79, 1, 0, 0, 0, 720, 721, 5, 39, 0, 0, 721,
		722, 5, 33, 0, 0, 722, 81, 1, 0, 0, 0, 723, 724, 5, 30, 0, 0, 724, 725,
		5, 45, 0, 0, 725, 726, 5, 39, 0, 0, 726, 727, 5, 33, 0, 0, 727, 83, 1,
		0, 0, 0, 728, 729, 5, 28, 0, 0, 729, 730, 5, 41, 0, 0, 730, 731, 5, 52,
		0, 0, 731, 732, 5, 30, 0, 0, 732, 733, 5, 45, 0, 0, 733, 734, 5, 39, 0,
		0, 734, 735, 5, 33, 0, 0, 735, 85, 1, 0, 0, 0, 736, 737, 5, 28, 0, 0, 737,
		738, 5, 41, 0, 0, 738, 739, 5, 52, 0, 0, 739, 87, 1, 0, 0, 0, 740, 741,
		5, 39, 0, 0, 741, 742, 5, 36, 0, 0, 742, 743, 5, 40, 0, 0, 743, 744, 5,
		36, 0, 0, 744, 745, 5, 47, 0, 0, 745, 746, 5, 19, 0, 0, 746, 747, 5, 40,
		0, 0, 747, 748, 5, 28, 0, 0, 748, 749, 5, 47, 0, 0, 749, 750, 5, 30, 0,
		0, 750, 751, 5, 35, 0, 0, 751, 89, 1, 0, 0, 0, 752, 753, 5, 39, 0, 0, 753,
		754, 5, 36, 0, 0, 754, 755, 5, 40, 0, 0, 755, 756, 5, 36, 0, 0, 756, 757,
		5, 47, 0, 0, 757, 758, 5, 19, 0, 0, 758, 759, 5, 45, 0, 0, 759, 760, 5,
		32, 0, 0, 760, 761, 5, 30, 0, 0, 761, 762, 5, 48, 0, 0, 762, 763, 5, 45,
		0, 0, 763, 764, 5, 46, 0, 0, 764, 765, 5, 36, 0, 0, 765, 766, 5, 42, 0,
		0, 766, 767, 5, 41, 0, 0, 767, 91, 1, 0, 0, 0, 768, 769, 5, 29, 0, 0, 769,
		770, 5, 46, 0, 0, 770, 771, 5, 45, 0, 0, 771, 772, 5, 19, 0, 0, 772, 773,
		5, 28, 0, 0, 773, 774, 5, 41, 0, 0, 774, 775, 5, 52, 0, 0, 775, 776, 5,
		30, 0, 0, 776, 777, 5, 45, 0, 0, 777, 778, 5, 39, 0, 0, 778, 779, 5, 33,
		0, 0, 779, 93, 1, 0, 0, 0, 780, 781, 5, 29, 0, 0, 781, 782, 5, 46, 0, 0,
		782, 783, 5, 45, 0, 0, 783, 784, 5, 19, 0, 0, 784, 785, 5, 48, 0, 0, 785,
		786, 5, 41, 0, 0, 786, 787, 5, 36, 0, 0, 787, 788, 5, 30, 0, 0, 788, 789,
		5, 42, 0, 0, 789, 790, 5, 31, 0, 0, 790, 791, 5, 32, 0, 0, 791, 95, 1,
		0, 0, 0, 792, 793, 5, 28, 0, 0, 793, 794, 5, 30, 0, 0, 794, 795, 5, 30,
		0, 0, 795, 796, 5, 32, 0, 0, 796, 797, 5, 43, 0, 0, 797, 798, 5, 47, 0,
		0, 798, 97, 1, 0, 0, 0, 799, 803, 5, 33, 0, 0, 800, 801, 5, 28, 0, 0, 801,
		802, 5, 36, 0, 0, 802, 804, 5, 39, 0, 0, 803, 800, 1, 0, 0, 0, 803, 804,
		1, 0, 0, 0, 804, 99, 1, 0, 0, 0, 805, 806, 5, 40, 0, 0, 806, 807, 5, 28,
		0, 0, 807, 808, 5, 45, 0, 0, 808, 809, 5, 38, 0, 0, 809, 101, 1, 0, 0,
		0, 810, 811, 5, 30, 0, 0, 811, 812, 5, 42, 0, 0, 812, 813, 5, 40, 0, 0,
		813, 814, 5, 40, 0, 0, 814, 815, 5, 36, 0, 0, 815, 816, 5, 47, 0, 0, 816,
		103, 1, 0, 0, 0, 817, 818, 5, 43, 0, 0, 818, 819, 5, 45, 0, 0, 819, 820,
		5, 48, 0, 0, 820, 821, 5, 41, 0, 0, 821, 822, 5, 32, 0, 0, 822, 105, 1,
		0, 0, 0, 823, 824, 5, 46, 0, 0, 824, 825, 5, 38, 0, 0, 825, 826, 5, 36,
		0, 0, 826, 827, 5, 43, 0, 0, 827, 107, 1, 0, 0, 0, 828, 829, 5, 47, 0,
		0, 829, 830, 5, 35, 0, 0, 830, 831, 5, 32, 0, 0, 831, 832, 5, 41, 0, 0,
		832, 109, 1, 0, 0, 0, 77, 111, 118, 122, 128, 132, 154, 178, 184, 186,
		188, 194, 196, 214, 225, 250, 259, 265, 273, 288, 295, 300, 302, 308, 321,
		327, 332, 337, 347, 354, 360, 362, 367, 369, 379, 395, 401, 407, 409, 415,
		417, 419, 430, 438, 443, 448, 450, 458, 467, 481, 483, 492, 507, 521, 523,
		536, 540, 548, 555, 565, 567, 571, 577, 583, 588, 592, 601, 609, 613, 622,
		632, 639, 644, 661, 666, 673, 675, 803,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// PCREParserInit initializes any static state used to implement PCREParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewPCREParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func PCREParserInit() {
	staticData := &PCREParserStaticData
	staticData.once.Do(pcreParserInit)
}

// NewPCREParser produces a new parser instance for the optional input antlr.TokenStream.
func NewPCREParser(input antlr.TokenStream) *PCREParser {
	PCREParserInit()
	this := new(PCREParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &PCREParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "PCRE.g4"

	return this
}

// PCREParser tokens.
const (
	PCREParserEOF         = antlr.TokenEOF
	PCREParserBSlash      = 1
	PCREParserDollar      = 2
	PCREParserDot         = 3
	PCREParserOBrack      = 4
	PCREParserCaret       = 5
	PCREParserPipe        = 6
	PCREParserQMark       = 7
	PCREParserStar        = 8
	PCREParserPlus        = 9
	PCREParserOBrace      = 10
	PCREParserCBrace      = 11
	PCREParserOPar        = 12
	PCREParserCPar        = 13
	PCREParserCBrack      = 14
	PCREParserOPosixBrack = 15
	PCREParserCPosixBrack = 16
	PCREParserComma       = 17
	PCREParserDash        = 18
	PCREParserUScore      = 19
	PCREParserEq          = 20
	PCREParserAmp         = 21
	PCREParserLt          = 22
	PCREParserGt          = 23
	PCREParserQuote       = 24
	PCREParserCol         = 25
	PCREParserHash        = 26
	PCREParserExcl        = 27
	PCREParserAu          = 28
	PCREParserBu          = 29
	PCREParserCu          = 30
	PCREParserDu          = 31
	PCREParserEu          = 32
	PCREParserFu          = 33
	PCREParserGu          = 34
	PCREParserHu          = 35
	PCREParserIu          = 36
	PCREParserJu          = 37
	PCREParserKu          = 38
	PCREParserLu          = 39
	PCREParserMu          = 40
	PCREParserNu          = 41
	PCREParserOu          = 42
	PCREParserPu          = 43
	PCREParserQu          = 44
	PCREParserRu          = 45
	PCREParserSu          = 46
	PCREParserTu          = 47
	PCREParserUu          = 48
	PCREParserVu          = 49
	PCREParserWu          = 50
	PCREParserXu          = 51
	PCREParserYu          = 52
	PCREParserZu          = 53
	PCREParserAl          = 54
	PCREParserBl          = 55
	PCREParserCl          = 56
	PCREParserDl          = 57
	PCREParserEl          = 58
	PCREParserFl          = 59
	PCREParserGl          = 60
	PCREParserHl          = 61
	PCREParserIl          = 62
	PCREParserJl          = 63
	PCREParserKl          = 64
	PCREParserLl          = 65
	PCREParserMl          = 66
	PCREParserNl          = 67
	PCREParserOl          = 68
	PCREParserPl          = 69
	PCREParserQl          = 70
	PCREParserRl          = 71
	PCREParserSl          = 72
	PCREParserTl          = 73
	PCREParserUl          = 74
	PCREParserVl          = 75
	PCREParserWl          = 76
	PCREParserXl          = 77
	PCREParserYl          = 78
	PCREParserZl          = 79
	PCREParserD0          = 80
	PCREParserD1          = 81
	PCREParserD2          = 82
	PCREParserD3          = 83
	PCREParserD4          = 84
	PCREParserD5          = 85
	PCREParserD6          = 86
	PCREParserD7          = 87
	PCREParserD8          = 88
	PCREParserD9          = 89
	PCREParserOTHER       = 90
)

// PCREParser rules.
const (
	PCREParserRULE_pcre                       = 0
	PCREParserRULE_alternation                = 1
	PCREParserRULE_expr                       = 2
	PCREParserRULE_element                    = 3
	PCREParserRULE_atom                       = 4
	PCREParserRULE_capture                    = 5
	PCREParserRULE_atomic_group               = 6
	PCREParserRULE_lookaround                 = 7
	PCREParserRULE_backreference              = 8
	PCREParserRULE_subroutine_reference       = 9
	PCREParserRULE_conditional_pattern        = 10
	PCREParserRULE_comment                    = 11
	PCREParserRULE_quantifier                 = 12
	PCREParserRULE_option_setting             = 13
	PCREParserRULE_option_setting_flag        = 14
	PCREParserRULE_backtracking_control       = 15
	PCREParserRULE_callout                    = 16
	PCREParserRULE_newline_conventions        = 17
	PCREParserRULE_character                  = 18
	PCREParserRULE_character_type             = 19
	PCREParserRULE_character_class            = 20
	PCREParserRULE_character_class_atom       = 21
	PCREParserRULE_character_class_range      = 22
	PCREParserRULE_character_class_range_atom = 23
	PCREParserRULE_posix_character_class      = 24
	PCREParserRULE_anchor                     = 25
	PCREParserRULE_match_point_reset          = 26
	PCREParserRULE_quoting                    = 27
	PCREParserRULE_digits                     = 28
	PCREParserRULE_digit                      = 29
	PCREParserRULE_hex                        = 30
	PCREParserRULE_letters                    = 31
	PCREParserRULE_letter                     = 32
	PCREParserRULE_name                       = 33
	PCREParserRULE_other                      = 34
	PCREParserRULE_utf                        = 35
	PCREParserRULE_ucp                        = 36
	PCREParserRULE_no_auto_possess            = 37
	PCREParserRULE_no_start_opt               = 38
	PCREParserRULE_cr                         = 39
	PCREParserRULE_lf                         = 40
	PCREParserRULE_crlf                       = 41
	PCREParserRULE_anycrlf                    = 42
	PCREParserRULE_any                        = 43
	PCREParserRULE_limit_match                = 44
	PCREParserRULE_limit_recursion            = 45
	PCREParserRULE_bsr_anycrlf                = 46
	PCREParserRULE_bsr_unicode                = 47
	PCREParserRULE_accept_                    = 48
	PCREParserRULE_fail                       = 49
	PCREParserRULE_mark                       = 50
	PCREParserRULE_commit                     = 51
	PCREParserRULE_prune                      = 52
	PCREParserRULE_skip                       = 53
	PCREParserRULE_then                       = 54
)

// IPcreContext is an interface to support dynamic dispatch.
type IPcreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Alternation() IAlternationContext

	// IsPcreContext differentiates from other interfaces.
	IsPcreContext()
}

type PcreContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPcreContext() *PcreContext {
	var p = new(PcreContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_pcre
	return p
}

func InitEmptyPcreContext(p *PcreContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_pcre
}

func (*PcreContext) IsPcreContext() {}

func NewPcreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PcreContext {
	var p = new(PcreContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_pcre

	return p
}

func (s *PcreContext) GetParser() antlr.Parser { return s.parser }

func (s *PcreContext) EOF() antlr.TerminalNode {
	return s.GetToken(PCREParserEOF, 0)
}

func (s *PcreContext) Alternation() IAlternationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlternationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *PcreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PcreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PcreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterPcre(s)
	}
}

func (s *PcreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitPcre(s)
	}
}

func (s *PcreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitPcre(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Pcre() (localctx IPcreContext) {
	localctx = NewPcreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, PCREParserRULE_pcre)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-75714) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
		{
			p.SetState(110)
			p.Alternation()
		}

	}
	{
		p.SetState(113)
		p.Match(PCREParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlternationContext is an interface to support dynamic dispatch.
type IAlternationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllPipe() []antlr.TerminalNode
	Pipe(i int) antlr.TerminalNode

	// IsAlternationContext differentiates from other interfaces.
	IsAlternationContext()
}

type AlternationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternationContext() *AlternationContext {
	var p = new(AlternationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_alternation
	return p
}

func InitEmptyAlternationContext(p *AlternationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_alternation
}

func (*AlternationContext) IsAlternationContext() {}

func NewAlternationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternationContext {
	var p = new(AlternationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_alternation

	return p
}

func (s *AlternationContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternationContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *AlternationContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AlternationContext) AllPipe() []antlr.TerminalNode {
	return s.GetTokens(PCREParserPipe)
}

func (s *AlternationContext) Pipe(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, i)
}

func (s *AlternationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAlternation(s)
	}
}

func (s *AlternationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAlternation(s)
	}
}

func (s *AlternationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAlternation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Alternation() (localctx IAlternationContext) {
	localctx = NewAlternationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, PCREParserRULE_alternation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(115)
		p.Expr()
	}
	p.SetState(122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == PCREParserPipe {
		{
			p.SetState(116)
			p.Match(PCREParserPipe)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(118)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-75714) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
			{
				p.SetState(117)
				p.Expr()
			}

		}

		p.SetState(124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllElement() []IElementContext
	Element(i int) IElementContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AllElement() []IElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElementContext); ok {
			len++
		}
	}

	tst := make([]IElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElementContext); ok {
			tst[i] = t.(IElementContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Element(i int) IElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElementContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, PCREParserRULE_expr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-75714) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
		{
			p.SetState(125)
			p.Element()
		}

		p.SetState(128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElementContext is an interface to support dynamic dispatch.
type IElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Atom() IAtomContext
	Quantifier() IQuantifierContext

	// IsElementContext differentiates from other interfaces.
	IsElementContext()
}

type ElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementContext() *ElementContext {
	var p = new(ElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_element
	return p
}

func InitEmptyElementContext(p *ElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_element
}

func (*ElementContext) IsElementContext() {}

func NewElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementContext {
	var p = new(ElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_element

	return p
}

func (s *ElementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementContext) Atom() IAtomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *ElementContext) Quantifier() IQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantifierContext)
}

func (s *ElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterElement(s)
	}
}

func (s *ElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitElement(s)
	}
}

func (s *ElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Element() (localctx IElementContext) {
	localctx = NewElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, PCREParserRULE_element)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(130)
		p.Atom()
	}
	p.SetState(132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1920) != 0 {
		{
			p.SetState(131)
			p.Quantifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Option_setting() IOption_settingContext
	Backtracking_control() IBacktracking_controlContext
	Callout() ICalloutContext
	Capture() ICaptureContext
	Atomic_group() IAtomic_groupContext
	Lookaround() ILookaroundContext
	Backreference() IBackreferenceContext
	Subroutine_reference() ISubroutine_referenceContext
	Conditional_pattern() IConditional_patternContext
	Comment() ICommentContext
	Character() ICharacterContext
	Character_type() ICharacter_typeContext
	Character_class() ICharacter_classContext
	Posix_character_class() IPosix_character_classContext
	Letter() ILetterContext
	Digit() IDigitContext
	Anchor() IAnchorContext
	Match_point_reset() IMatch_point_resetContext
	Quoting() IQuotingContext
	Other() IOtherContext

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_atom
	return p
}

func InitEmptyAtomContext(p *AtomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_atom
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Option_setting() IOption_settingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOption_settingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOption_settingContext)
}

func (s *AtomContext) Backtracking_control() IBacktracking_controlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBacktracking_controlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBacktracking_controlContext)
}

func (s *AtomContext) Callout() ICalloutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalloutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalloutContext)
}

func (s *AtomContext) Capture() ICaptureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaptureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaptureContext)
}

func (s *AtomContext) Atomic_group() IAtomic_groupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtomic_groupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtomic_groupContext)
}

func (s *AtomContext) Lookaround() ILookaroundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookaroundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookaroundContext)
}

func (s *AtomContext) Backreference() IBackreferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackreferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackreferenceContext)
}

func (s *AtomContext) Subroutine_reference() ISubroutine_referenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubroutine_referenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubroutine_referenceContext)
}

func (s *AtomContext) Conditional_pattern() IConditional_patternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditional_patternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditional_patternContext)
}

func (s *AtomContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *AtomContext) Character() ICharacterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterContext)
}

func (s *AtomContext) Character_type() ICharacter_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_typeContext)
}

func (s *AtomContext) Character_class() ICharacter_classContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_classContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_classContext)
}

func (s *AtomContext) Posix_character_class() IPosix_character_classContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPosix_character_classContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPosix_character_classContext)
}

func (s *AtomContext) Letter() ILetterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *AtomContext) Digit() IDigitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *AtomContext) Anchor() IAnchorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnchorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnchorContext)
}

func (s *AtomContext) Match_point_reset() IMatch_point_resetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatch_point_resetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatch_point_resetContext)
}

func (s *AtomContext) Quoting() IQuotingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuotingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuotingContext)
}

func (s *AtomContext) Other() IOtherContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOtherContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOtherContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (s *AtomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAtom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, PCREParserRULE_atom)
	p.SetState(154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(134)
			p.Option_setting()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(135)
			p.Backtracking_control()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(136)
			p.Callout()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(137)
			p.Capture()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(138)
			p.Atomic_group()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(139)
			p.Lookaround()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(140)
			p.Backreference()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(141)
			p.Subroutine_reference()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(142)
			p.Conditional_pattern()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(143)
			p.Comment()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(144)
			p.Character()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(145)
			p.Character_type()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(146)
			p.Character_class()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(147)
			p.Posix_character_class()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(148)
			p.Letter()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(149)
			p.Digit()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(150)
			p.Anchor()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(151)
			p.Match_point_reset()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(152)
			p.Quoting()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(153)
			p.Other()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaptureContext is an interface to support dynamic dispatch.
type ICaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	CPar() antlr.TerminalNode
	Alternation() IAlternationContext
	QMark() antlr.TerminalNode
	Lt() antlr.TerminalNode
	Name() INameContext
	Gt() antlr.TerminalNode
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	Pu() antlr.TerminalNode
	Col() antlr.TerminalNode
	Pipe() antlr.TerminalNode
	AllOption_setting_flag() []IOption_setting_flagContext
	Option_setting_flag(i int) IOption_setting_flagContext
	Dash() antlr.TerminalNode

	// IsCaptureContext differentiates from other interfaces.
	IsCaptureContext()
}

type CaptureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureContext() *CaptureContext {
	var p = new(CaptureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_capture
	return p
}

func InitEmptyCaptureContext(p *CaptureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_capture
}

func (*CaptureContext) IsCaptureContext() {}

func NewCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureContext {
	var p = new(CaptureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_capture

	return p
}

func (s *CaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *CaptureContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *CaptureContext) Alternation() IAlternationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlternationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *CaptureContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *CaptureContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *CaptureContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *CaptureContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *CaptureContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserQuote)
}

func (s *CaptureContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserQuote, i)
}

func (s *CaptureContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *CaptureContext) Col() antlr.TerminalNode {
	return s.GetToken(PCREParserCol, 0)
}

func (s *CaptureContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *CaptureContext) AllOption_setting_flag() []IOption_setting_flagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOption_setting_flagContext); ok {
			len++
		}
	}

	tst := make([]IOption_setting_flagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOption_setting_flagContext); ok {
			tst[i] = t.(IOption_setting_flagContext)
			i++
		}
	}

	return tst
}

func (s *CaptureContext) Option_setting_flag(i int) IOption_setting_flagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOption_setting_flagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOption_setting_flagContext)
}

func (s *CaptureContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *CaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCapture(s)
	}
}

func (s *CaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCapture(s)
	}
}

func (s *CaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Capture() (localctx ICaptureContext) {
	localctx = NewCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, PCREParserRULE_capture)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(156)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(196)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserBSlash, PCREParserDollar, PCREParserDot, PCREParserOBrack, PCREParserCaret, PCREParserCBrace, PCREParserOPar, PCREParserCBrack, PCREParserOPosixBrack, PCREParserComma, PCREParserDash, PCREParserUScore, PCREParserEq, PCREParserAmp, PCREParserLt, PCREParserGt, PCREParserQuote, PCREParserCol, PCREParserHash, PCREParserExcl, PCREParserAu, PCREParserBu, PCREParserCu, PCREParserDu, PCREParserEu, PCREParserFu, PCREParserGu, PCREParserHu, PCREParserIu, PCREParserJu, PCREParserKu, PCREParserLu, PCREParserMu, PCREParserNu, PCREParserOu, PCREParserPu, PCREParserQu, PCREParserRu, PCREParserSu, PCREParserTu, PCREParserUu, PCREParserVu, PCREParserWu, PCREParserXu, PCREParserYu, PCREParserZu, PCREParserAl, PCREParserBl, PCREParserCl, PCREParserDl, PCREParserEl, PCREParserFl, PCREParserGl, PCREParserHl, PCREParserIl, PCREParserJl, PCREParserKl, PCREParserLl, PCREParserMl, PCREParserNl, PCREParserOl, PCREParserPl, PCREParserQl, PCREParserRl, PCREParserSl, PCREParserTl, PCREParserUl, PCREParserVl, PCREParserWl, PCREParserXl, PCREParserYl, PCREParserZl, PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserOTHER:
		{
			p.SetState(157)
			p.Alternation()
		}

	case PCREParserQMark:
		{
			p.SetState(158)
			p.Match(PCREParserQMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case PCREParserLt:
			{
				p.SetState(159)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(160)
				p.Name()
			}
			{
				p.SetState(161)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(162)
				p.Alternation()
			}

		case PCREParserQuote:
			{
				p.SetState(164)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(165)
				p.Name()
			}
			{
				p.SetState(166)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(167)
				p.Alternation()
			}

		case PCREParserPu:
			{
				p.SetState(169)
				p.Match(PCREParserPu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(170)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(171)
				p.Name()
			}
			{
				p.SetState(172)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(173)
				p.Alternation()
			}

		case PCREParserCol, PCREParserJu, PCREParserUu, PCREParserIl, PCREParserMl, PCREParserSl, PCREParserXl:
			p.SetState(188)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0 {
				p.SetState(176)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
					{
						p.SetState(175)
						p.Option_setting_flag()
					}

					p.SetState(178)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				p.SetState(186)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == PCREParserDash {
					{
						p.SetState(180)
						p.Match(PCREParserDash)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					p.SetState(182)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					for ok := true; ok; ok = ((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
						{
							p.SetState(181)
							p.Option_setting_flag()
						}

						p.SetState(184)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)
					}

				}

			}
			{
				p.SetState(190)
				p.Match(PCREParserCol)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(191)
				p.Alternation()
			}

		case PCREParserPipe:
			{
				p.SetState(192)
				p.Match(PCREParserPipe)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(193)
				p.Alternation()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(198)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAtomic_groupContext is an interface to support dynamic dispatch.
type IAtomic_groupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Gt() antlr.TerminalNode
	Alternation() IAlternationContext
	CPar() antlr.TerminalNode

	// IsAtomic_groupContext differentiates from other interfaces.
	IsAtomic_groupContext()
}

type Atomic_groupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomic_groupContext() *Atomic_groupContext {
	var p = new(Atomic_groupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_atomic_group
	return p
}

func InitEmptyAtomic_groupContext(p *Atomic_groupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_atomic_group
}

func (*Atomic_groupContext) IsAtomic_groupContext() {}

func NewAtomic_groupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atomic_groupContext {
	var p = new(Atomic_groupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_atomic_group

	return p
}

func (s *Atomic_groupContext) GetParser() antlr.Parser { return s.parser }

func (s *Atomic_groupContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *Atomic_groupContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *Atomic_groupContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *Atomic_groupContext) Alternation() IAlternationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlternationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *Atomic_groupContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *Atomic_groupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atomic_groupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atomic_groupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAtomic_group(s)
	}
}

func (s *Atomic_groupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAtomic_group(s)
	}
}

func (s *Atomic_groupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAtomic_group(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Atomic_group() (localctx IAtomic_groupContext) {
	localctx = NewAtomic_groupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, PCREParserRULE_atomic_group)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(200)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(201)
		p.Match(PCREParserQMark)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(202)
		p.Match(PCREParserGt)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(203)
		p.Alternation()
	}
	{
		p.SetState(204)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookaroundContext is an interface to support dynamic dispatch.
type ILookaroundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Alternation() IAlternationContext
	CPar() antlr.TerminalNode
	Eq() antlr.TerminalNode
	Excl() antlr.TerminalNode
	Lt() antlr.TerminalNode

	// IsLookaroundContext differentiates from other interfaces.
	IsLookaroundContext()
}

type LookaroundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookaroundContext() *LookaroundContext {
	var p = new(LookaroundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_lookaround
	return p
}

func InitEmptyLookaroundContext(p *LookaroundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_lookaround
}

func (*LookaroundContext) IsLookaroundContext() {}

func NewLookaroundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookaroundContext {
	var p = new(LookaroundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_lookaround

	return p
}

func (s *LookaroundContext) GetParser() antlr.Parser { return s.parser }

func (s *LookaroundContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *LookaroundContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *LookaroundContext) Alternation() IAlternationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlternationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlternationContext)
}

func (s *LookaroundContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *LookaroundContext) Eq() antlr.TerminalNode {
	return s.GetToken(PCREParserEq, 0)
}

func (s *LookaroundContext) Excl() antlr.TerminalNode {
	return s.GetToken(PCREParserExcl, 0)
}

func (s *LookaroundContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *LookaroundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookaroundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookaroundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLookaround(s)
	}
}

func (s *LookaroundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLookaround(s)
	}
}

func (s *LookaroundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLookaround(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Lookaround() (localctx ILookaroundContext) {
	localctx = NewLookaroundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, PCREParserRULE_lookaround)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(207)
		p.Match(PCREParserQMark)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(208)
			p.Match(PCREParserEq)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(209)
			p.Match(PCREParserExcl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(210)
			p.Match(PCREParserLt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(211)
			p.Match(PCREParserEq)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(212)
			p.Match(PCREParserLt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(213)
			p.Match(PCREParserExcl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(216)
		p.Alternation()
	}
	{
		p.SetState(217)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackreferenceContext is an interface to support dynamic dispatch.
type IBackreferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BSlash() antlr.TerminalNode
	Gl() antlr.TerminalNode
	Digits() IDigitsContext
	OBrace() antlr.TerminalNode
	CBrace() antlr.TerminalNode
	Name() INameContext
	Kl() antlr.TerminalNode
	Lt() antlr.TerminalNode
	Gt() antlr.TerminalNode
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	Dash() antlr.TerminalNode
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Pu() antlr.TerminalNode
	Eq() antlr.TerminalNode
	CPar() antlr.TerminalNode

	// IsBackreferenceContext differentiates from other interfaces.
	IsBackreferenceContext()
}

type BackreferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackreferenceContext() *BackreferenceContext {
	var p = new(BackreferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_backreference
	return p
}

func InitEmptyBackreferenceContext(p *BackreferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_backreference
}

func (*BackreferenceContext) IsBackreferenceContext() {}

func NewBackreferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackreferenceContext {
	var p = new(BackreferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backreference

	return p
}

func (s *BackreferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *BackreferenceContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *BackreferenceContext) Gl() antlr.TerminalNode {
	return s.GetToken(PCREParserGl, 0)
}

func (s *BackreferenceContext) Digits() IDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *BackreferenceContext) OBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOBrace, 0)
}

func (s *BackreferenceContext) CBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrace, 0)
}

func (s *BackreferenceContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *BackreferenceContext) Kl() antlr.TerminalNode {
	return s.GetToken(PCREParserKl, 0)
}

func (s *BackreferenceContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *BackreferenceContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *BackreferenceContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserQuote)
}

func (s *BackreferenceContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserQuote, i)
}

func (s *BackreferenceContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *BackreferenceContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *BackreferenceContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *BackreferenceContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *BackreferenceContext) Eq() antlr.TerminalNode {
	return s.GetToken(PCREParserEq, 0)
}

func (s *BackreferenceContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *BackreferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackreferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackreferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBackreference(s)
	}
}

func (s *BackreferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBackreference(s)
	}
}

func (s *BackreferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBackreference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Backreference() (localctx IBackreferenceContext) {
	localctx = NewBackreferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, PCREParserRULE_backreference)
	var _la int

	p.SetState(259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserBSlash:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(219)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(220)
				p.Match(PCREParserGl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(221)
				p.Digits()
			}

		case 2:
			{
				p.SetState(222)
				p.Match(PCREParserGl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(223)
				p.Match(PCREParserOBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(225)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserDash {
				{
					p.SetState(224)
					p.Match(PCREParserDash)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(227)
				p.Digits()
			}
			{
				p.SetState(228)
				p.Match(PCREParserCBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(230)
				p.Match(PCREParserGl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(231)
				p.Match(PCREParserOBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(232)
				p.Name()
			}
			{
				p.SetState(233)
				p.Match(PCREParserCBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(235)
				p.Match(PCREParserKl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(236)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(237)
				p.Name()
			}
			{
				p.SetState(238)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(240)
				p.Match(PCREParserKl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(241)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(242)
				p.Name()
			}
			{
				p.SetState(243)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(245)
				p.Match(PCREParserKl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(246)
				p.Match(PCREParserOBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(247)
				p.Name()
			}
			{
				p.SetState(248)
				p.Match(PCREParserCBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case PCREParserOPar:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(252)
			p.Match(PCREParserOPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(253)
			p.Match(PCREParserQMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(254)
			p.Match(PCREParserPu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(255)
			p.Match(PCREParserEq)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(256)
			p.Name()
		}
		{
			p.SetState(257)
			p.Match(PCREParserCPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubroutine_referenceContext is an interface to support dynamic dispatch.
type ISubroutine_referenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	CPar() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Digits() IDigitsContext
	Amp() antlr.TerminalNode
	Name() INameContext
	Pu() antlr.TerminalNode
	Gt() antlr.TerminalNode
	Plus() antlr.TerminalNode
	Dash() antlr.TerminalNode
	BSlash() antlr.TerminalNode
	Gl() antlr.TerminalNode
	Lt() antlr.TerminalNode
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode

	// IsSubroutine_referenceContext differentiates from other interfaces.
	IsSubroutine_referenceContext()
}

type Subroutine_referenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubroutine_referenceContext() *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_subroutine_reference
	return p
}

func InitEmptySubroutine_referenceContext(p *Subroutine_referenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_subroutine_reference
}

func (*Subroutine_referenceContext) IsSubroutine_referenceContext() {}

func NewSubroutine_referenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subroutine_referenceContext {
	var p = new(Subroutine_referenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_subroutine_reference

	return p
}

func (s *Subroutine_referenceContext) GetParser() antlr.Parser { return s.parser }

func (s *Subroutine_referenceContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *Subroutine_referenceContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *Subroutine_referenceContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *Subroutine_referenceContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *Subroutine_referenceContext) Digits() IDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *Subroutine_referenceContext) Amp() antlr.TerminalNode {
	return s.GetToken(PCREParserAmp, 0)
}

func (s *Subroutine_referenceContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Subroutine_referenceContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *Subroutine_referenceContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *Subroutine_referenceContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Subroutine_referenceContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *Subroutine_referenceContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *Subroutine_referenceContext) Gl() antlr.TerminalNode {
	return s.GetToken(PCREParserGl, 0)
}

func (s *Subroutine_referenceContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *Subroutine_referenceContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserQuote)
}

func (s *Subroutine_referenceContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserQuote, i)
}

func (s *Subroutine_referenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subroutine_referenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subroutine_referenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterSubroutine_reference(s)
	}
}

func (s *Subroutine_referenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitSubroutine_reference(s)
	}
}

func (s *Subroutine_referenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitSubroutine_reference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Subroutine_reference() (localctx ISubroutine_referenceContext) {
	localctx = NewSubroutine_referenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, PCREParserRULE_subroutine_reference)
	var _la int

	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserOPar:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.Match(PCREParserOPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(262)
			p.Match(PCREParserQMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case PCREParserRu:
			{
				p.SetState(263)
				p.Match(PCREParserRu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case PCREParserPlus, PCREParserDash, PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9:
			p.SetState(265)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserPlus || _la == PCREParserDash {
				{
					p.SetState(264)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PCREParserPlus || _la == PCREParserDash) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(267)
				p.Digits()
			}

		case PCREParserAmp:
			{
				p.SetState(268)
				p.Match(PCREParserAmp)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(269)
				p.Name()
			}

		case PCREParserPu:
			{
				p.SetState(270)
				p.Match(PCREParserPu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(271)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(272)
				p.Name()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(275)
			p.Match(PCREParserCPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserBSlash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(276)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)
			p.Match(PCREParserGl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(300)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(278)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(279)
				p.Name()
			}
			{
				p.SetState(280)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(282)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(283)
				p.Name()
			}
			{
				p.SetState(284)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(286)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(288)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserPlus || _la == PCREParserDash {
				{
					p.SetState(287)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PCREParserPlus || _la == PCREParserDash) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(290)
				p.Digits()
			}
			{
				p.SetState(291)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(293)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(295)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserPlus || _la == PCREParserDash {
				{
					p.SetState(294)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PCREParserPlus || _la == PCREParserDash) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(297)
				p.Digits()
			}
			{
				p.SetState(298)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditional_patternContext is an interface to support dynamic dispatch.
type IConditional_patternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNo_pattern returns the no_pattern rule contexts.
	GetNo_pattern() IExprContext

	// SetNo_pattern sets the no_pattern rule contexts.
	SetNo_pattern(IExprContext)

	// Getter signatures
	AllOPar() []antlr.TerminalNode
	OPar(i int) antlr.TerminalNode
	QMark() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCPar() []antlr.TerminalNode
	CPar(i int) antlr.TerminalNode
	Callout() ICalloutContext
	Lookaround() ILookaroundContext
	Pipe() antlr.TerminalNode
	Digits() IDigitsContext
	Lt() antlr.TerminalNode
	Name() INameContext
	Gt() antlr.TerminalNode
	AllQuote() []antlr.TerminalNode
	Quote(i int) antlr.TerminalNode
	Ru() antlr.TerminalNode
	Amp() antlr.TerminalNode
	Plus() antlr.TerminalNode
	Dash() antlr.TerminalNode

	// IsConditional_patternContext differentiates from other interfaces.
	IsConditional_patternContext()
}

type Conditional_patternContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	no_pattern IExprContext
}

func NewEmptyConditional_patternContext() *Conditional_patternContext {
	var p = new(Conditional_patternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_conditional_pattern
	return p
}

func InitEmptyConditional_patternContext(p *Conditional_patternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_conditional_pattern
}

func (*Conditional_patternContext) IsConditional_patternContext() {}

func NewConditional_patternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Conditional_patternContext {
	var p = new(Conditional_patternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_conditional_pattern

	return p
}

func (s *Conditional_patternContext) GetParser() antlr.Parser { return s.parser }

func (s *Conditional_patternContext) GetNo_pattern() IExprContext { return s.no_pattern }

func (s *Conditional_patternContext) SetNo_pattern(v IExprContext) { s.no_pattern = v }

func (s *Conditional_patternContext) AllOPar() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOPar)
}

func (s *Conditional_patternContext) OPar(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, i)
}

func (s *Conditional_patternContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *Conditional_patternContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *Conditional_patternContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *Conditional_patternContext) AllCPar() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCPar)
}

func (s *Conditional_patternContext) CPar(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, i)
}

func (s *Conditional_patternContext) Callout() ICalloutContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalloutContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalloutContext)
}

func (s *Conditional_patternContext) Lookaround() ILookaroundContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookaroundContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookaroundContext)
}

func (s *Conditional_patternContext) Pipe() antlr.TerminalNode {
	return s.GetToken(PCREParserPipe, 0)
}

func (s *Conditional_patternContext) Digits() IDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *Conditional_patternContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *Conditional_patternContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Conditional_patternContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *Conditional_patternContext) AllQuote() []antlr.TerminalNode {
	return s.GetTokens(PCREParserQuote)
}

func (s *Conditional_patternContext) Quote(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserQuote, i)
}

func (s *Conditional_patternContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *Conditional_patternContext) Amp() antlr.TerminalNode {
	return s.GetToken(PCREParserAmp, 0)
}

func (s *Conditional_patternContext) Plus() antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, 0)
}

func (s *Conditional_patternContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *Conditional_patternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Conditional_patternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Conditional_patternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterConditional_pattern(s)
	}
}

func (s *Conditional_patternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitConditional_pattern(s)
	}
}

func (s *Conditional_patternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitConditional_pattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Conditional_pattern() (localctx IConditional_patternContext) {
	localctx = NewConditional_patternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, PCREParserRULE_conditional_pattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(304)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(305)
		p.Match(PCREParserQMark)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(306)
			p.Match(PCREParserOPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
		case 1:
			p.SetState(308)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserPlus || _la == PCREParserDash {
				{
					p.SetState(307)
					_la = p.GetTokenStream().LA(1)

					if !(_la == PCREParserPlus || _la == PCREParserDash) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(310)
				p.Digits()
			}

		case 2:
			{
				p.SetState(311)
				p.Match(PCREParserLt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(312)
				p.Name()
			}
			{
				p.SetState(313)
				p.Match(PCREParserGt)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(315)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(316)
				p.Name()
			}
			{
				p.SetState(317)
				p.Match(PCREParserQuote)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(319)
				p.Match(PCREParserRu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(321)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1023) != 0 {
				{
					p.SetState(320)
					p.Digits()
				}

			}

		case 5:
			{
				p.SetState(323)
				p.Match(PCREParserRu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(324)
				p.Match(PCREParserAmp)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(325)
				p.Name()
			}

		case 6:
			{
				p.SetState(326)
				p.Name()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(329)
			p.Match(PCREParserCPar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(330)
			p.Callout()
		}

	case 3:
		{
			p.SetState(331)
			p.Lookaround()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(334)
		p.Expr()
	}
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == PCREParserPipe {
		{
			p.SetState(335)
			p.Match(PCREParserPipe)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)

			var _x = p.Expr()

			localctx.(*Conditional_patternContext).no_pattern = _x
		}

	}
	{
		p.SetState(339)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Hash() antlr.TerminalNode
	AllCPar() []antlr.TerminalNode
	CPar(i int) antlr.TerminalNode

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *CommentContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *CommentContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *CommentContext) AllCPar() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCPar)
}

func (s *CommentContext) CPar(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, i)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, PCREParserRULE_comment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(341)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(342)
		p.Match(PCREParserQMark)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(343)
		p.Match(PCREParserHash)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8194) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
		{
			p.SetState(344)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == PCREParserCPar {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(349)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantifierContext is an interface to support dynamic dispatch.
type IQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPossessive returns the possessive token.
	GetPossessive() antlr.Token

	// GetLazy returns the lazy token.
	GetLazy() antlr.Token

	// SetPossessive sets the possessive token.
	SetPossessive(antlr.Token)

	// SetLazy sets the lazy token.
	SetLazy(antlr.Token)

	// GetFrom returns the from rule contexts.
	GetFrom() IDigitsContext

	// GetTo returns the to rule contexts.
	GetTo() IDigitsContext

	// SetFrom sets the from rule contexts.
	SetFrom(IDigitsContext)

	// SetTo sets the to rule contexts.
	SetTo(IDigitsContext)

	// Getter signatures
	AllQMark() []antlr.TerminalNode
	QMark(i int) antlr.TerminalNode
	Star() antlr.TerminalNode
	AllPlus() []antlr.TerminalNode
	Plus(i int) antlr.TerminalNode
	OBrace() antlr.TerminalNode
	CBrace() antlr.TerminalNode
	AllDigits() []IDigitsContext
	Digits(i int) IDigitsContext
	Comma() antlr.TerminalNode

	// IsQuantifierContext differentiates from other interfaces.
	IsQuantifierContext()
}

type QuantifierContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	possessive antlr.Token
	lazy       antlr.Token
	from       IDigitsContext
	to         IDigitsContext
}

func NewEmptyQuantifierContext() *QuantifierContext {
	var p = new(QuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier
	return p
}

func InitEmptyQuantifierContext(p *QuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_quantifier
}

func (*QuantifierContext) IsQuantifierContext() {}

func NewQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantifierContext {
	var p = new(QuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quantifier

	return p
}

func (s *QuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantifierContext) GetPossessive() antlr.Token { return s.possessive }

func (s *QuantifierContext) GetLazy() antlr.Token { return s.lazy }

func (s *QuantifierContext) SetPossessive(v antlr.Token) { s.possessive = v }

func (s *QuantifierContext) SetLazy(v antlr.Token) { s.lazy = v }

func (s *QuantifierContext) GetFrom() IDigitsContext { return s.from }

func (s *QuantifierContext) GetTo() IDigitsContext { return s.to }

func (s *QuantifierContext) SetFrom(v IDigitsContext) { s.from = v }

func (s *QuantifierContext) SetTo(v IDigitsContext) { s.to = v }

func (s *QuantifierContext) AllQMark() []antlr.TerminalNode {
	return s.GetTokens(PCREParserQMark)
}

func (s *QuantifierContext) QMark(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, i)
}

func (s *QuantifierContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *QuantifierContext) AllPlus() []antlr.TerminalNode {
	return s.GetTokens(PCREParserPlus)
}

func (s *QuantifierContext) Plus(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserPlus, i)
}

func (s *QuantifierContext) OBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOBrace, 0)
}

func (s *QuantifierContext) CBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrace, 0)
}

func (s *QuantifierContext) AllDigits() []IDigitsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDigitsContext); ok {
			len++
		}
	}

	tst := make([]IDigitsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDigitsContext); ok {
			tst[i] = t.(IDigitsContext)
			i++
		}
	}

	return tst
}

func (s *QuantifierContext) Digits(i int) IDigitsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *QuantifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *QuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuantifier(s)
	}
}

func (s *QuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuantifier(s)
	}
}

func (s *QuantifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitQuantifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Quantifier() (localctx IQuantifierContext) {
	localctx = NewQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, PCREParserRULE_quantifier)
	var _la int

	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserQMark, PCREParserStar, PCREParserPlus:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(351)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&896) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case PCREParserPlus:
			{
				p.SetState(352)

				var _m = p.Match(PCREParserPlus)

				localctx.(*QuantifierContext).possessive = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case PCREParserQMark:
			{
				p.SetState(353)

				var _m = p.Match(PCREParserQMark)

				localctx.(*QuantifierContext).lazy = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case PCREParserEOF, PCREParserBSlash, PCREParserDollar, PCREParserDot, PCREParserOBrack, PCREParserCaret, PCREParserPipe, PCREParserCBrace, PCREParserOPar, PCREParserCPar, PCREParserCBrack, PCREParserOPosixBrack, PCREParserComma, PCREParserDash, PCREParserUScore, PCREParserEq, PCREParserAmp, PCREParserLt, PCREParserGt, PCREParserQuote, PCREParserCol, PCREParserHash, PCREParserExcl, PCREParserAu, PCREParserBu, PCREParserCu, PCREParserDu, PCREParserEu, PCREParserFu, PCREParserGu, PCREParserHu, PCREParserIu, PCREParserJu, PCREParserKu, PCREParserLu, PCREParserMu, PCREParserNu, PCREParserOu, PCREParserPu, PCREParserQu, PCREParserRu, PCREParserSu, PCREParserTu, PCREParserUu, PCREParserVu, PCREParserWu, PCREParserXu, PCREParserYu, PCREParserZu, PCREParserAl, PCREParserBl, PCREParserCl, PCREParserDl, PCREParserEl, PCREParserFl, PCREParserGl, PCREParserHl, PCREParserIl, PCREParserJl, PCREParserKl, PCREParserLl, PCREParserMl, PCREParserNl, PCREParserOl, PCREParserPl, PCREParserQl, PCREParserRl, PCREParserSl, PCREParserTl, PCREParserUl, PCREParserVl, PCREParserWl, PCREParserXl, PCREParserYl, PCREParserZl, PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserOTHER:

		default:
		}

	case PCREParserOBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(356)
			p.Match(PCREParserOBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)

			var _x = p.Digits()

			localctx.(*QuantifierContext).from = _x
		}
		p.SetState(362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserComma {
			{
				p.SetState(358)
				p.Match(PCREParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(360)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if (int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1023) != 0 {
				{
					p.SetState(359)

					var _x = p.Digits()

					localctx.(*QuantifierContext).to = _x
				}

			}

		}
		{
			p.SetState(364)
			p.Match(PCREParserCBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case PCREParserPlus:
			{
				p.SetState(365)

				var _m = p.Match(PCREParserPlus)

				localctx.(*QuantifierContext).possessive = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case PCREParserQMark:
			{
				p.SetState(366)

				var _m = p.Match(PCREParserQMark)

				localctx.(*QuantifierContext).lazy = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case PCREParserEOF, PCREParserBSlash, PCREParserDollar, PCREParserDot, PCREParserOBrack, PCREParserCaret, PCREParserPipe, PCREParserCBrace, PCREParserOPar, PCREParserCPar, PCREParserCBrack, PCREParserOPosixBrack, PCREParserComma, PCREParserDash, PCREParserUScore, PCREParserEq, PCREParserAmp, PCREParserLt, PCREParserGt, PCREParserQuote, PCREParserCol, PCREParserHash, PCREParserExcl, PCREParserAu, PCREParserBu, PCREParserCu, PCREParserDu, PCREParserEu, PCREParserFu, PCREParserGu, PCREParserHu, PCREParserIu, PCREParserJu, PCREParserKu, PCREParserLu, PCREParserMu, PCREParserNu, PCREParserOu, PCREParserPu, PCREParserQu, PCREParserRu, PCREParserSu, PCREParserTu, PCREParserUu, PCREParserVu, PCREParserWu, PCREParserXu, PCREParserYu, PCREParserZu, PCREParserAl, PCREParserBl, PCREParserCl, PCREParserDl, PCREParserEl, PCREParserFl, PCREParserGl, PCREParserHl, PCREParserIl, PCREParserJl, PCREParserKl, PCREParserLl, PCREParserMl, PCREParserNl, PCREParserOl, PCREParserPl, PCREParserQl, PCREParserRl, PCREParserSl, PCREParserTl, PCREParserUl, PCREParserVl, PCREParserWl, PCREParserXl, PCREParserYl, PCREParserZl, PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9, PCREParserOTHER:

		default:
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOption_settingContext is an interface to support dynamic dispatch.
type IOption_settingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	CPar() antlr.TerminalNode
	Star() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Utf() IUtfContext
	Ucp() IUcpContext
	No_auto_possess() INo_auto_possessContext
	No_start_opt() INo_start_optContext
	Newline_conventions() INewline_conventionsContext
	Limit_match() ILimit_matchContext
	Eq() antlr.TerminalNode
	Digits() IDigitsContext
	Limit_recursion() ILimit_recursionContext
	Bsr_anycrlf() IBsr_anycrlfContext
	Bsr_unicode() IBsr_unicodeContext
	Dash() antlr.TerminalNode
	D8() antlr.TerminalNode
	D1() antlr.TerminalNode
	D6() antlr.TerminalNode
	D3() antlr.TerminalNode
	D2() antlr.TerminalNode
	AllOption_setting_flag() []IOption_setting_flagContext
	Option_setting_flag(i int) IOption_setting_flagContext

	// IsOption_settingContext differentiates from other interfaces.
	IsOption_settingContext()
}

type Option_settingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_settingContext() *Option_settingContext {
	var p = new(Option_settingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_option_setting
	return p
}

func InitEmptyOption_settingContext(p *Option_settingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_option_setting
}

func (*Option_settingContext) IsOption_settingContext() {}

func NewOption_settingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_settingContext {
	var p = new(Option_settingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_setting

	return p
}

func (s *Option_settingContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_settingContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *Option_settingContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *Option_settingContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Option_settingContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *Option_settingContext) Utf() IUtfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtfContext)
}

func (s *Option_settingContext) Ucp() IUcpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUcpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUcpContext)
}

func (s *Option_settingContext) No_auto_possess() INo_auto_possessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_auto_possessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_auto_possessContext)
}

func (s *Option_settingContext) No_start_opt() INo_start_optContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INo_start_optContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INo_start_optContext)
}

func (s *Option_settingContext) Newline_conventions() INewline_conventionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewline_conventionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewline_conventionsContext)
}

func (s *Option_settingContext) Limit_match() ILimit_matchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_matchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_matchContext)
}

func (s *Option_settingContext) Eq() antlr.TerminalNode {
	return s.GetToken(PCREParserEq, 0)
}

func (s *Option_settingContext) Digits() IDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *Option_settingContext) Limit_recursion() ILimit_recursionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimit_recursionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimit_recursionContext)
}

func (s *Option_settingContext) Bsr_anycrlf() IBsr_anycrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBsr_anycrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBsr_anycrlfContext)
}

func (s *Option_settingContext) Bsr_unicode() IBsr_unicodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBsr_unicodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBsr_unicodeContext)
}

func (s *Option_settingContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *Option_settingContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *Option_settingContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *Option_settingContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *Option_settingContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *Option_settingContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *Option_settingContext) AllOption_setting_flag() []IOption_setting_flagContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOption_setting_flagContext); ok {
			len++
		}
	}

	tst := make([]IOption_setting_flagContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOption_setting_flagContext); ok {
			tst[i] = t.(IOption_setting_flagContext)
			i++
		}
	}

	return tst
}

func (s *Option_settingContext) Option_setting_flag(i int) IOption_setting_flagContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOption_setting_flagContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOption_setting_flagContext)
}

func (s *Option_settingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_settingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_settingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_setting(s)
	}
}

func (s *Option_settingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_setting(s)
	}
}

func (s *Option_settingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOption_setting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Option_setting() (localctx IOption_settingContext) {
	localctx = NewOption_settingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, PCREParserRULE_option_setting)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserStar:
		{
			p.SetState(372)
			p.Match(PCREParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(373)
				p.Utf()
			}
			p.SetState(379)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case PCREParserD8:
				{
					p.SetState(374)
					p.Match(PCREParserD8)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case PCREParserD1:
				{
					p.SetState(375)
					p.Match(PCREParserD1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(376)
					p.Match(PCREParserD6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case PCREParserD3:
				{
					p.SetState(377)
					p.Match(PCREParserD3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(378)
					p.Match(PCREParserD2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case PCREParserCPar:

			default:
			}

		case 2:
			{
				p.SetState(381)
				p.Ucp()
			}

		case 3:
			{
				p.SetState(382)
				p.No_auto_possess()
			}

		case 4:
			{
				p.SetState(383)
				p.No_start_opt()
			}

		case 5:
			{
				p.SetState(384)
				p.Newline_conventions()
			}

		case 6:
			{
				p.SetState(385)
				p.Limit_match()
			}
			{
				p.SetState(386)
				p.Match(PCREParserEq)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(387)
				p.Digits()
			}

		case 7:
			{
				p.SetState(389)
				p.Limit_recursion()
			}
			{
				p.SetState(390)
				p.Match(PCREParserEq)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(391)
				p.Digits()
			}

		case 8:
			{
				p.SetState(393)
				p.Bsr_anycrlf()
			}

		case 9:
			{
				p.SetState(394)
				p.Bsr_unicode()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case PCREParserQMark:
		{
			p.SetState(397)
			p.Match(PCREParserQMark)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case PCREParserJu, PCREParserUu, PCREParserIl, PCREParserMl, PCREParserSl, PCREParserXl:
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
				{
					p.SetState(398)
					p.Option_setting_flag()
				}

				p.SetState(401)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(409)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserDash {
				{
					p.SetState(403)
					p.Match(PCREParserDash)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(405)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = ((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
					{
						p.SetState(404)
						p.Option_setting_flag()
					}

					p.SetState(407)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}

		case PCREParserDash:
			{
				p.SetState(411)
				p.Match(PCREParserDash)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(413)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
				{
					p.SetState(412)
					p.Option_setting_flag()
				}

				p.SetState(415)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(421)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOption_setting_flagContext is an interface to support dynamic dispatch.
type IOption_setting_flagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Il() antlr.TerminalNode
	Ju() antlr.TerminalNode
	Ml() antlr.TerminalNode
	Sl() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Xl() antlr.TerminalNode

	// IsOption_setting_flagContext differentiates from other interfaces.
	IsOption_setting_flagContext()
}

type Option_setting_flagContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOption_setting_flagContext() *Option_setting_flagContext {
	var p = new(Option_setting_flagContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_option_setting_flag
	return p
}

func InitEmptyOption_setting_flagContext(p *Option_setting_flagContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_option_setting_flag
}

func (*Option_setting_flagContext) IsOption_setting_flagContext() {}

func NewOption_setting_flagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Option_setting_flagContext {
	var p = new(Option_setting_flagContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_option_setting_flag

	return p
}

func (s *Option_setting_flagContext) GetParser() antlr.Parser { return s.parser }

func (s *Option_setting_flagContext) Il() antlr.TerminalNode {
	return s.GetToken(PCREParserIl, 0)
}

func (s *Option_setting_flagContext) Ju() antlr.TerminalNode {
	return s.GetToken(PCREParserJu, 0)
}

func (s *Option_setting_flagContext) Ml() antlr.TerminalNode {
	return s.GetToken(PCREParserMl, 0)
}

func (s *Option_setting_flagContext) Sl() antlr.TerminalNode {
	return s.GetToken(PCREParserSl, 0)
}

func (s *Option_setting_flagContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *Option_setting_flagContext) Xl() antlr.TerminalNode {
	return s.GetToken(PCREParserXl, 0)
}

func (s *Option_setting_flagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Option_setting_flagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Option_setting_flagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOption_setting_flag(s)
	}
}

func (s *Option_setting_flagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOption_setting_flag(s)
	}
}

func (s *Option_setting_flagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOption_setting_flag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Option_setting_flag() (localctx IOption_setting_flagContext) {
	localctx = NewOption_setting_flagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, PCREParserRULE_option_setting_flag)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(423)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-37)) & ^0x3f) == 0 && ((int64(1)<<(_la-37))&1134441793537) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBacktracking_controlContext is an interface to support dynamic dispatch.
type IBacktracking_controlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	Star() antlr.TerminalNode
	CPar() antlr.TerminalNode
	Accept_() IAccept_Context
	Fail() IFailContext
	Col() antlr.TerminalNode
	Name() INameContext
	Commit() ICommitContext
	Prune() IPruneContext
	Skip() ISkipContext
	Then() IThenContext
	Mark() IMarkContext

	// IsBacktracking_controlContext differentiates from other interfaces.
	IsBacktracking_controlContext()
}

type Backtracking_controlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBacktracking_controlContext() *Backtracking_controlContext {
	var p = new(Backtracking_controlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_backtracking_control
	return p
}

func InitEmptyBacktracking_controlContext(p *Backtracking_controlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_backtracking_control
}

func (*Backtracking_controlContext) IsBacktracking_controlContext() {}

func NewBacktracking_controlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Backtracking_controlContext {
	var p = new(Backtracking_controlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_backtracking_control

	return p
}

func (s *Backtracking_controlContext) GetParser() antlr.Parser { return s.parser }

func (s *Backtracking_controlContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *Backtracking_controlContext) Star() antlr.TerminalNode {
	return s.GetToken(PCREParserStar, 0)
}

func (s *Backtracking_controlContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *Backtracking_controlContext) Accept_() IAccept_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccept_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccept_Context)
}

func (s *Backtracking_controlContext) Fail() IFailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFailContext)
}

func (s *Backtracking_controlContext) Col() antlr.TerminalNode {
	return s.GetToken(PCREParserCol, 0)
}

func (s *Backtracking_controlContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Backtracking_controlContext) Commit() ICommitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitContext)
}

func (s *Backtracking_controlContext) Prune() IPruneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPruneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPruneContext)
}

func (s *Backtracking_controlContext) Skip() ISkipContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISkipContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISkipContext)
}

func (s *Backtracking_controlContext) Then() IThenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThenContext)
}

func (s *Backtracking_controlContext) Mark() IMarkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMarkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMarkContext)
}

func (s *Backtracking_controlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Backtracking_controlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Backtracking_controlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBacktracking_control(s)
	}
}

func (s *Backtracking_controlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBacktracking_control(s)
	}
}

func (s *Backtracking_controlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBacktracking_control(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Backtracking_control() (localctx IBacktracking_controlContext) {
	localctx = NewBacktracking_controlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, PCREParserRULE_backtracking_control)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(425)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(426)
		p.Match(PCREParserStar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserAu:
		{
			p.SetState(427)
			p.Accept_()
		}

	case PCREParserFu:
		{
			p.SetState(428)
			p.Fail()
		}

	case PCREParserCol, PCREParserMu:
		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserMu {
			{
				p.SetState(429)
				p.Mark()
			}

		}
		{
			p.SetState(432)
			p.Match(PCREParserCol)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(433)
			p.Name()
		}

	case PCREParserCu:
		{
			p.SetState(434)
			p.Commit()
		}

	case PCREParserPu:
		{
			p.SetState(435)
			p.Prune()
		}
		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserCol {
			{
				p.SetState(436)
				p.Match(PCREParserCol)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(437)
				p.Name()
			}

		}

	case PCREParserSu:
		{
			p.SetState(440)
			p.Skip()
		}
		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserCol {
			{
				p.SetState(441)
				p.Match(PCREParserCol)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(442)
				p.Name()
			}

		}

	case PCREParserTu:
		{
			p.SetState(445)
			p.Then()
		}
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserCol {
			{
				p.SetState(446)
				p.Match(PCREParserCol)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(447)
				p.Name()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(452)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICalloutContext is an interface to support dynamic dispatch.
type ICalloutContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPar() antlr.TerminalNode
	QMark() antlr.TerminalNode
	Cu() antlr.TerminalNode
	CPar() antlr.TerminalNode
	Digits() IDigitsContext

	// IsCalloutContext differentiates from other interfaces.
	IsCalloutContext()
}

type CalloutContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalloutContext() *CalloutContext {
	var p = new(CalloutContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_callout
	return p
}

func InitEmptyCalloutContext(p *CalloutContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_callout
}

func (*CalloutContext) IsCalloutContext() {}

func NewCalloutContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalloutContext {
	var p = new(CalloutContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_callout

	return p
}

func (s *CalloutContext) GetParser() antlr.Parser { return s.parser }

func (s *CalloutContext) OPar() antlr.TerminalNode {
	return s.GetToken(PCREParserOPar, 0)
}

func (s *CalloutContext) QMark() antlr.TerminalNode {
	return s.GetToken(PCREParserQMark, 0)
}

func (s *CalloutContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *CalloutContext) CPar() antlr.TerminalNode {
	return s.GetToken(PCREParserCPar, 0)
}

func (s *CalloutContext) Digits() IDigitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitsContext)
}

func (s *CalloutContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalloutContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalloutContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCallout(s)
	}
}

func (s *CalloutContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCallout(s)
	}
}

func (s *CalloutContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCallout(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Callout() (localctx ICalloutContext) {
	localctx = NewCalloutContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, PCREParserRULE_callout)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(454)
		p.Match(PCREParserOPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(455)
		p.Match(PCREParserQMark)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(456)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1023) != 0 {
		{
			p.SetState(457)
			p.Digits()
		}

	}
	{
		p.SetState(460)
		p.Match(PCREParserCPar)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewline_conventionsContext is an interface to support dynamic dispatch.
type INewline_conventionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cr() ICrContext
	Lf() ILfContext
	Crlf() ICrlfContext
	Anycrlf() IAnycrlfContext
	Any() IAnyContext

	// IsNewline_conventionsContext differentiates from other interfaces.
	IsNewline_conventionsContext()
}

type Newline_conventionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewline_conventionsContext() *Newline_conventionsContext {
	var p = new(Newline_conventionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_newline_conventions
	return p
}

func InitEmptyNewline_conventionsContext(p *Newline_conventionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_newline_conventions
}

func (*Newline_conventionsContext) IsNewline_conventionsContext() {}

func NewNewline_conventionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Newline_conventionsContext {
	var p = new(Newline_conventionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_newline_conventions

	return p
}

func (s *Newline_conventionsContext) GetParser() antlr.Parser { return s.parser }

func (s *Newline_conventionsContext) Cr() ICrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *Newline_conventionsContext) Lf() ILfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *Newline_conventionsContext) Crlf() ICrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Newline_conventionsContext) Anycrlf() IAnycrlfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnycrlfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnycrlfContext)
}

func (s *Newline_conventionsContext) Any() IAnyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnyContext)
}

func (s *Newline_conventionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Newline_conventionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Newline_conventionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNewline_conventions(s)
	}
}

func (s *Newline_conventionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNewline_conventions(s)
	}
}

func (s *Newline_conventionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNewline_conventions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Newline_conventions() (localctx INewline_conventionsContext) {
	localctx = NewNewline_conventionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, PCREParserRULE_newline_conventions)
	p.SetState(467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(462)
			p.Cr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(463)
			p.Lf()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(464)
			p.Crlf()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(465)
			p.Anycrlf()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(466)
			p.Any()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacterContext is an interface to support dynamic dispatch.
type ICharacterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BSlash() antlr.TerminalNode
	Al() antlr.TerminalNode
	Cl() antlr.TerminalNode
	El() antlr.TerminalNode
	Fl() antlr.TerminalNode
	Nl() antlr.TerminalNode
	Rl() antlr.TerminalNode
	Tl() antlr.TerminalNode
	AllDigit() []IDigitContext
	Digit(i int) IDigitContext
	Ol() antlr.TerminalNode
	OBrace() antlr.TerminalNode
	CBrace() antlr.TerminalNode
	Xl() antlr.TerminalNode
	AllHex() []IHexContext
	Hex(i int) IHexContext
	Ul() antlr.TerminalNode

	// IsCharacterContext differentiates from other interfaces.
	IsCharacterContext()
}

type CharacterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterContext() *CharacterContext {
	var p = new(CharacterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character
	return p
}

func InitEmptyCharacterContext(p *CharacterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character
}

func (*CharacterContext) IsCharacterContext() {}

func NewCharacterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterContext {
	var p = new(CharacterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character

	return p
}

func (s *CharacterContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *CharacterContext) Al() antlr.TerminalNode {
	return s.GetToken(PCREParserAl, 0)
}

func (s *CharacterContext) Cl() antlr.TerminalNode {
	return s.GetToken(PCREParserCl, 0)
}

func (s *CharacterContext) El() antlr.TerminalNode {
	return s.GetToken(PCREParserEl, 0)
}

func (s *CharacterContext) Fl() antlr.TerminalNode {
	return s.GetToken(PCREParserFl, 0)
}

func (s *CharacterContext) Nl() antlr.TerminalNode {
	return s.GetToken(PCREParserNl, 0)
}

func (s *CharacterContext) Rl() antlr.TerminalNode {
	return s.GetToken(PCREParserRl, 0)
}

func (s *CharacterContext) Tl() antlr.TerminalNode {
	return s.GetToken(PCREParserTl, 0)
}

func (s *CharacterContext) AllDigit() []IDigitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDigitContext); ok {
			len++
		}
	}

	tst := make([]IDigitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDigitContext); ok {
			tst[i] = t.(IDigitContext)
			i++
		}
	}

	return tst
}

func (s *CharacterContext) Digit(i int) IDigitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *CharacterContext) Ol() antlr.TerminalNode {
	return s.GetToken(PCREParserOl, 0)
}

func (s *CharacterContext) OBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOBrace, 0)
}

func (s *CharacterContext) CBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrace, 0)
}

func (s *CharacterContext) Xl() antlr.TerminalNode {
	return s.GetToken(PCREParserXl, 0)
}

func (s *CharacterContext) AllHex() []IHexContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHexContext); ok {
			len++
		}
	}

	tst := make([]IHexContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHexContext); ok {
			tst[i] = t.(IHexContext)
			i++
		}
	}

	return tst
}

func (s *CharacterContext) Hex(i int) IHexContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHexContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHexContext)
}

func (s *CharacterContext) Ul() antlr.TerminalNode {
	return s.GetToken(PCREParserUl, 0)
}

func (s *CharacterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter(s)
	}
}

func (s *CharacterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter(s)
	}
}

func (s *CharacterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character() (localctx ICharacterContext) {
	localctx = NewCharacterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, PCREParserRULE_character)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(PCREParserBSlash)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(470)
			p.Match(PCREParserAl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(471)
			p.Match(PCREParserCl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(472)
		p.MatchWildcard()

	case 3:
		{
			p.SetState(473)
			p.Match(PCREParserEl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(474)
			p.Match(PCREParserFl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		{
			p.SetState(475)
			p.Match(PCREParserNl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		{
			p.SetState(476)
			p.Match(PCREParserRl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		{
			p.SetState(477)
			p.Match(PCREParserTl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		{
			p.SetState(478)
			p.Digit()
		}
		p.SetState(483)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(479)
				p.Digit()
			}
			p.SetState(481)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(480)
					p.Digit()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		{
			p.SetState(485)
			p.Match(PCREParserOl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Match(PCREParserOBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(487)
			p.Digit()
		}
		{
			p.SetState(488)
			p.Digit()
		}
		p.SetState(490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1023) != 0) {
			{
				p.SetState(489)
				p.Digit()
			}

			p.SetState(492)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(494)
			p.Match(PCREParserCBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		{
			p.SetState(496)
			p.Match(PCREParserXl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(497)
			p.Hex()
		}
		{
			p.SetState(498)
			p.Hex()
		}

	case 11:
		{
			p.SetState(500)
			p.Match(PCREParserXl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.Match(PCREParserOBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.Hex()
		}
		{
			p.SetState(503)
			p.Hex()
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64((_la-28)) & ^0x3f) == 0 && ((int64(1)<<(_la-28))&4607182423027875903) != 0) {
			{
				p.SetState(504)
				p.Hex()
			}

			p.SetState(507)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(509)
			p.Match(PCREParserCBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		{
			p.SetState(511)
			p.Match(PCREParserUl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.Hex()
		}
		{
			p.SetState(513)
			p.Hex()
		}
		{
			p.SetState(514)
			p.Hex()
		}
		{
			p.SetState(515)
			p.Hex()
		}
		p.SetState(521)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(516)
				p.Hex()
			}
			{
				p.SetState(517)
				p.Hex()
			}
			{
				p.SetState(518)
				p.Hex()
			}
			{
				p.SetState(519)
				p.Hex()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacter_typeContext is an interface to support dynamic dispatch.
type ICharacter_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Dot() antlr.TerminalNode
	BSlash() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Dl() antlr.TerminalNode
	Du() antlr.TerminalNode
	Hl() antlr.TerminalNode
	Hu() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Pl() antlr.TerminalNode
	OBrace() antlr.TerminalNode
	Name() INameContext
	CBrace() antlr.TerminalNode
	Pu() antlr.TerminalNode
	AllLetter() []ILetterContext
	Letter(i int) ILetterContext
	Ru() antlr.TerminalNode
	Sl() antlr.TerminalNode
	Su() antlr.TerminalNode
	Vl() antlr.TerminalNode
	Vu() antlr.TerminalNode
	Wl() antlr.TerminalNode
	Wu() antlr.TerminalNode
	Xu() antlr.TerminalNode
	Caret() antlr.TerminalNode
	Amp() antlr.TerminalNode

	// IsCharacter_typeContext differentiates from other interfaces.
	IsCharacter_typeContext()
}

type Character_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_typeContext() *Character_typeContext {
	var p = new(Character_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_type
	return p
}

func InitEmptyCharacter_typeContext(p *Character_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_type
}

func (*Character_typeContext) IsCharacter_typeContext() {}

func NewCharacter_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_typeContext {
	var p = new(Character_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_type

	return p
}

func (s *Character_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_typeContext) Dot() antlr.TerminalNode {
	return s.GetToken(PCREParserDot, 0)
}

func (s *Character_typeContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *Character_typeContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *Character_typeContext) Dl() antlr.TerminalNode {
	return s.GetToken(PCREParserDl, 0)
}

func (s *Character_typeContext) Du() antlr.TerminalNode {
	return s.GetToken(PCREParserDu, 0)
}

func (s *Character_typeContext) Hl() antlr.TerminalNode {
	return s.GetToken(PCREParserHl, 0)
}

func (s *Character_typeContext) Hu() antlr.TerminalNode {
	return s.GetToken(PCREParserHu, 0)
}

func (s *Character_typeContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *Character_typeContext) Pl() antlr.TerminalNode {
	return s.GetToken(PCREParserPl, 0)
}

func (s *Character_typeContext) OBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserOBrace, 0)
}

func (s *Character_typeContext) Name() INameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Character_typeContext) CBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrace, 0)
}

func (s *Character_typeContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *Character_typeContext) AllLetter() []ILetterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetterContext); ok {
			len++
		}
	}

	tst := make([]ILetterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetterContext); ok {
			tst[i] = t.(ILetterContext)
			i++
		}
	}

	return tst
}

func (s *Character_typeContext) Letter(i int) ILetterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *Character_typeContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *Character_typeContext) Sl() antlr.TerminalNode {
	return s.GetToken(PCREParserSl, 0)
}

func (s *Character_typeContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *Character_typeContext) Vl() antlr.TerminalNode {
	return s.GetToken(PCREParserVl, 0)
}

func (s *Character_typeContext) Vu() antlr.TerminalNode {
	return s.GetToken(PCREParserVu, 0)
}

func (s *Character_typeContext) Wl() antlr.TerminalNode {
	return s.GetToken(PCREParserWl, 0)
}

func (s *Character_typeContext) Wu() antlr.TerminalNode {
	return s.GetToken(PCREParserWu, 0)
}

func (s *Character_typeContext) Xu() antlr.TerminalNode {
	return s.GetToken(PCREParserXu, 0)
}

func (s *Character_typeContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Character_typeContext) Amp() antlr.TerminalNode {
	return s.GetToken(PCREParserAmp, 0)
}

func (s *Character_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_type(s)
	}
}

func (s *Character_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_type(s)
	}
}

func (s *Character_typeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_type(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_type() (localctx ICharacter_typeContext) {
	localctx = NewCharacter_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, PCREParserRULE_character_type)
	var _la int

	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserDot:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)
			p.Match(PCREParserDot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserBSlash:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(526)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(527)
				p.Match(PCREParserCu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(528)
				p.Match(PCREParserDl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(529)
				p.Match(PCREParserDu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(530)
				p.Match(PCREParserHl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(531)
				p.Match(PCREParserHu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(532)
				p.Match(PCREParserNu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(533)
				p.Match(PCREParserPl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(534)
				p.Match(PCREParserOBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(536)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserCaret {
				{
					p.SetState(535)
					p.Match(PCREParserCaret)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(538)
				p.Name()
			}
			p.SetState(540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserAmp {
				{
					p.SetState(539)
					p.Match(PCREParserAmp)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(542)
				p.Match(PCREParserCBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(544)
				p.Match(PCREParserPu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(545)
				p.Match(PCREParserOBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(546)
				p.Name()
			}
			p.SetState(548)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == PCREParserAmp {
				{
					p.SetState(547)
					p.Match(PCREParserAmp)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(550)
				p.Match(PCREParserCBrace)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(552)
				p.Match(PCREParserPl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(553)
				p.Letter()
			}
			p.SetState(555)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(554)
					p.Letter()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 10:
			{
				p.SetState(557)
				p.Match(PCREParserRu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 11:
			{
				p.SetState(558)
				p.Match(PCREParserSl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 12:
			{
				p.SetState(559)
				p.Match(PCREParserSu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 13:
			{
				p.SetState(560)
				p.Match(PCREParserVl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 14:
			{
				p.SetState(561)
				p.Match(PCREParserVu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 15:
			{
				p.SetState(562)
				p.Match(PCREParserWl)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 16:
			{
				p.SetState(563)
				p.Match(PCREParserWu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 17:
			{
				p.SetState(564)
				p.Match(PCREParserXu)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacter_classContext is an interface to support dynamic dispatch.
type ICharacter_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNegate returns the negate token.
	GetNegate() antlr.Token

	// SetNegate sets the negate token.
	SetNegate(antlr.Token)

	// Getter signatures
	OBrack() antlr.TerminalNode
	AllCBrack() []antlr.TerminalNode
	CBrack(i int) antlr.TerminalNode
	AllCharacter_class_atom() []ICharacter_class_atomContext
	Character_class_atom(i int) ICharacter_class_atomContext
	Caret() antlr.TerminalNode

	// IsCharacter_classContext differentiates from other interfaces.
	IsCharacter_classContext()
}

type Character_classContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	negate antlr.Token
}

func NewEmptyCharacter_classContext() *Character_classContext {
	var p = new(Character_classContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class
	return p
}

func InitEmptyCharacter_classContext(p *Character_classContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class
}

func (*Character_classContext) IsCharacter_classContext() {}

func NewCharacter_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_classContext {
	var p = new(Character_classContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class

	return p
}

func (s *Character_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_classContext) GetNegate() antlr.Token { return s.negate }

func (s *Character_classContext) SetNegate(v antlr.Token) { s.negate = v }

func (s *Character_classContext) OBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserOBrack, 0)
}

func (s *Character_classContext) AllCBrack() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCBrack)
}

func (s *Character_classContext) CBrack(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCBrack, i)
}

func (s *Character_classContext) AllCharacter_class_atom() []ICharacter_class_atomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharacter_class_atomContext); ok {
			len++
		}
	}

	tst := make([]ICharacter_class_atomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharacter_class_atomContext); ok {
			tst[i] = t.(ICharacter_class_atomContext)
			i++
		}
	}

	return tst
}

func (s *Character_classContext) Character_class_atom(i int) ICharacter_class_atomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_class_atomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_class_atomContext)
}

func (s *Character_classContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Character_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class(s)
	}
}

func (s *Character_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class(s)
	}
}

func (s *Character_classContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_class(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_class() (localctx ICharacter_classContext) {
	localctx = NewCharacter_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, PCREParserRULE_character_class)
	var _la int

	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(569)
			p.Match(PCREParserOBrack)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == PCREParserCaret {
			{
				p.SetState(570)

				var _m = p.Match(PCREParserCaret)

				localctx.(*Character_classContext).negate = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(573)
			p.Match(PCREParserCBrack)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
			{
				p.SetState(574)
				p.Character_class_atom()
			}

			p.SetState(579)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(580)
			p.Match(PCREParserCBrack)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(581)
			p.Match(PCREParserOBrack)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(582)

				var _m = p.Match(PCREParserCaret)

				localctx.(*Character_classContext).negate = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-16386) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&134217727) != 0) {
			{
				p.SetState(585)
				p.Character_class_atom()
			}

			p.SetState(588)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(590)
			p.Match(PCREParserCBrack)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacter_class_atomContext is an interface to support dynamic dispatch.
type ICharacter_class_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Character_class_range() ICharacter_class_rangeContext
	Posix_character_class() IPosix_character_classContext
	Character() ICharacterContext
	Character_type() ICharacter_typeContext
	BSlash() antlr.TerminalNode
	CBrack() antlr.TerminalNode

	// IsCharacter_class_atomContext differentiates from other interfaces.
	IsCharacter_class_atomContext()
}

type Character_class_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_class_atomContext() *Character_class_atomContext {
	var p = new(Character_class_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_atom
	return p
}

func InitEmptyCharacter_class_atomContext(p *Character_class_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_atom
}

func (*Character_class_atomContext) IsCharacter_class_atomContext() {}

func NewCharacter_class_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_class_atomContext {
	var p = new(Character_class_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class_atom

	return p
}

func (s *Character_class_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_class_atomContext) Character_class_range() ICharacter_class_rangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_class_rangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_class_rangeContext)
}

func (s *Character_class_atomContext) Posix_character_class() IPosix_character_classContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPosix_character_classContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPosix_character_classContext)
}

func (s *Character_class_atomContext) Character() ICharacterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterContext)
}

func (s *Character_class_atomContext) Character_type() ICharacter_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_typeContext)
}

func (s *Character_class_atomContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *Character_class_atomContext) CBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrack, 0)
}

func (s *Character_class_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_class_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_class_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class_atom(s)
	}
}

func (s *Character_class_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class_atom(s)
	}
}

func (s *Character_class_atomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_class_atom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_class_atom() (localctx ICharacter_class_atomContext) {
	localctx = NewCharacter_class_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, PCREParserRULE_character_class_atom)
	var _la int

	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.Character_class_range()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Posix_character_class()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(596)
			p.Character()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(597)
			p.Character_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(598)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(599)
		p.MatchWildcard()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(600)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == PCREParserBSlash || _la == PCREParserCBrack {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacter_class_rangeContext is an interface to support dynamic dispatch.
type ICharacter_class_rangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCharacter_class_range_atom() []ICharacter_class_range_atomContext
	Character_class_range_atom(i int) ICharacter_class_range_atomContext
	Dash() antlr.TerminalNode

	// IsCharacter_class_rangeContext differentiates from other interfaces.
	IsCharacter_class_rangeContext()
}

type Character_class_rangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_class_rangeContext() *Character_class_rangeContext {
	var p = new(Character_class_rangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_range
	return p
}

func InitEmptyCharacter_class_rangeContext(p *Character_class_rangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_range
}

func (*Character_class_rangeContext) IsCharacter_class_rangeContext() {}

func NewCharacter_class_rangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_class_rangeContext {
	var p = new(Character_class_rangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class_range

	return p
}

func (s *Character_class_rangeContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_class_rangeContext) AllCharacter_class_range_atom() []ICharacter_class_range_atomContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICharacter_class_range_atomContext); ok {
			len++
		}
	}

	tst := make([]ICharacter_class_range_atomContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICharacter_class_range_atomContext); ok {
			tst[i] = t.(ICharacter_class_range_atomContext)
			i++
		}
	}

	return tst
}

func (s *Character_class_rangeContext) Character_class_range_atom(i int) ICharacter_class_range_atomContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacter_class_range_atomContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacter_class_range_atomContext)
}

func (s *Character_class_rangeContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *Character_class_rangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_class_rangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_class_rangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class_range(s)
	}
}

func (s *Character_class_rangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class_range(s)
	}
}

func (s *Character_class_rangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_class_range(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_class_range() (localctx ICharacter_class_rangeContext) {
	localctx = NewCharacter_class_rangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, PCREParserRULE_character_class_range)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(603)
		p.Character_class_range_atom()
	}
	{
		p.SetState(604)
		p.Match(PCREParserDash)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(605)
		p.Character_class_range_atom()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharacter_class_range_atomContext is an interface to support dynamic dispatch.
type ICharacter_class_range_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Character() ICharacterContext
	CBrack() antlr.TerminalNode

	// IsCharacter_class_range_atomContext differentiates from other interfaces.
	IsCharacter_class_range_atomContext()
}

type Character_class_range_atomContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacter_class_range_atomContext() *Character_class_range_atomContext {
	var p = new(Character_class_range_atomContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_range_atom
	return p
}

func InitEmptyCharacter_class_range_atomContext(p *Character_class_range_atomContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_character_class_range_atom
}

func (*Character_class_range_atomContext) IsCharacter_class_range_atomContext() {}

func NewCharacter_class_range_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Character_class_range_atomContext {
	var p = new(Character_class_range_atomContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_character_class_range_atom

	return p
}

func (s *Character_class_range_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Character_class_range_atomContext) Character() ICharacterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterContext)
}

func (s *Character_class_range_atomContext) CBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrack, 0)
}

func (s *Character_class_range_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Character_class_range_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Character_class_range_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCharacter_class_range_atom(s)
	}
}

func (s *Character_class_range_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCharacter_class_range_atom(s)
	}
}

func (s *Character_class_range_atomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCharacter_class_range_atom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Character_class_range_atom() (localctx ICharacter_class_range_atomContext) {
	localctx = NewCharacter_class_range_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, PCREParserRULE_character_class_range_atom)
	var _la int

	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(607)
			p.Character()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(608)
			_la = p.GetTokenStream().LA(1)

			if _la <= 0 || _la == PCREParserCBrack {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPosix_character_classContext is an interface to support dynamic dispatch.
type IPosix_character_classContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNegate returns the negate token.
	GetNegate() antlr.Token

	// SetNegate sets the negate token.
	SetNegate(antlr.Token)

	// Getter signatures
	OPosixBrack() antlr.TerminalNode
	Letters() ILettersContext
	CPosixBrack() antlr.TerminalNode
	Caret() antlr.TerminalNode

	// IsPosix_character_classContext differentiates from other interfaces.
	IsPosix_character_classContext()
}

type Posix_character_classContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	negate antlr.Token
}

func NewEmptyPosix_character_classContext() *Posix_character_classContext {
	var p = new(Posix_character_classContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_posix_character_class
	return p
}

func InitEmptyPosix_character_classContext(p *Posix_character_classContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_posix_character_class
}

func (*Posix_character_classContext) IsPosix_character_classContext() {}

func NewPosix_character_classContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Posix_character_classContext {
	var p = new(Posix_character_classContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_posix_character_class

	return p
}

func (s *Posix_character_classContext) GetParser() antlr.Parser { return s.parser }

func (s *Posix_character_classContext) GetNegate() antlr.Token { return s.negate }

func (s *Posix_character_classContext) SetNegate(v antlr.Token) { s.negate = v }

func (s *Posix_character_classContext) OPosixBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserOPosixBrack, 0)
}

func (s *Posix_character_classContext) Letters() ILettersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILettersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILettersContext)
}

func (s *Posix_character_classContext) CPosixBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserCPosixBrack, 0)
}

func (s *Posix_character_classContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *Posix_character_classContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Posix_character_classContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Posix_character_classContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterPosix_character_class(s)
	}
}

func (s *Posix_character_classContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitPosix_character_class(s)
	}
}

func (s *Posix_character_classContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitPosix_character_class(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Posix_character_class() (localctx IPosix_character_classContext) {
	localctx = NewPosix_character_classContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, PCREParserRULE_posix_character_class)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(PCREParserOPosixBrack)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == PCREParserCaret {
		{
			p.SetState(612)

			var _m = p.Match(PCREParserCaret)

			localctx.(*Posix_character_classContext).negate = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(615)
		p.Letters()
	}
	{
		p.SetState(616)
		p.Match(PCREParserCPosixBrack)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnchorContext is an interface to support dynamic dispatch.
type IAnchorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BSlash() antlr.TerminalNode
	Bl() antlr.TerminalNode
	Bu() antlr.TerminalNode
	Au() antlr.TerminalNode
	Zl() antlr.TerminalNode
	Zu() antlr.TerminalNode
	Gu() antlr.TerminalNode
	Caret() antlr.TerminalNode
	Dollar() antlr.TerminalNode

	// IsAnchorContext differentiates from other interfaces.
	IsAnchorContext()
}

type AnchorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnchorContext() *AnchorContext {
	var p = new(AnchorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_anchor
	return p
}

func InitEmptyAnchorContext(p *AnchorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_anchor
}

func (*AnchorContext) IsAnchorContext() {}

func NewAnchorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnchorContext {
	var p = new(AnchorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_anchor

	return p
}

func (s *AnchorContext) GetParser() antlr.Parser { return s.parser }

func (s *AnchorContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *AnchorContext) Bl() antlr.TerminalNode {
	return s.GetToken(PCREParserBl, 0)
}

func (s *AnchorContext) Bu() antlr.TerminalNode {
	return s.GetToken(PCREParserBu, 0)
}

func (s *AnchorContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *AnchorContext) Zl() antlr.TerminalNode {
	return s.GetToken(PCREParserZl, 0)
}

func (s *AnchorContext) Zu() antlr.TerminalNode {
	return s.GetToken(PCREParserZu, 0)
}

func (s *AnchorContext) Gu() antlr.TerminalNode {
	return s.GetToken(PCREParserGu, 0)
}

func (s *AnchorContext) Caret() antlr.TerminalNode {
	return s.GetToken(PCREParserCaret, 0)
}

func (s *AnchorContext) Dollar() antlr.TerminalNode {
	return s.GetToken(PCREParserDollar, 0)
}

func (s *AnchorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnchorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnchorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAnchor(s)
	}
}

func (s *AnchorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAnchor(s)
	}
}

func (s *AnchorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAnchor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Anchor() (localctx IAnchorContext) {
	localctx = NewAnchorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, PCREParserRULE_anchor)
	var _la int

	p.SetState(622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserBSlash:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(618)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-28)) & ^0x3f) == 0 && ((int64(1)<<(_la-28))&2251799981457475) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case PCREParserCaret:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.Match(PCREParserCaret)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserDollar:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(621)
			p.Match(PCREParserDollar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatch_point_resetContext is an interface to support dynamic dispatch.
type IMatch_point_resetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BSlash() antlr.TerminalNode
	Ku() antlr.TerminalNode

	// IsMatch_point_resetContext differentiates from other interfaces.
	IsMatch_point_resetContext()
}

type Match_point_resetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatch_point_resetContext() *Match_point_resetContext {
	var p = new(Match_point_resetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_match_point_reset
	return p
}

func InitEmptyMatch_point_resetContext(p *Match_point_resetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_match_point_reset
}

func (*Match_point_resetContext) IsMatch_point_resetContext() {}

func NewMatch_point_resetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Match_point_resetContext {
	var p = new(Match_point_resetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_match_point_reset

	return p
}

func (s *Match_point_resetContext) GetParser() antlr.Parser { return s.parser }

func (s *Match_point_resetContext) BSlash() antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, 0)
}

func (s *Match_point_resetContext) Ku() antlr.TerminalNode {
	return s.GetToken(PCREParserKu, 0)
}

func (s *Match_point_resetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Match_point_resetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Match_point_resetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterMatch_point_reset(s)
	}
}

func (s *Match_point_resetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitMatch_point_reset(s)
	}
}

func (s *Match_point_resetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitMatch_point_reset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Match_point_reset() (localctx IMatch_point_resetContext) {
	localctx = NewMatch_point_resetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, PCREParserRULE_match_point_reset)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.Match(PCREParserBSlash)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(625)
		p.Match(PCREParserKu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuotingContext is an interface to support dynamic dispatch.
type IQuotingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBSlash() []antlr.TerminalNode
	BSlash(i int) antlr.TerminalNode
	Qu() antlr.TerminalNode
	Eu() antlr.TerminalNode

	// IsQuotingContext differentiates from other interfaces.
	IsQuotingContext()
}

type QuotingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuotingContext() *QuotingContext {
	var p = new(QuotingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_quoting
	return p
}

func InitEmptyQuotingContext(p *QuotingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_quoting
}

func (*QuotingContext) IsQuotingContext() {}

func NewQuotingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuotingContext {
	var p = new(QuotingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_quoting

	return p
}

func (s *QuotingContext) GetParser() antlr.Parser { return s.parser }

func (s *QuotingContext) AllBSlash() []antlr.TerminalNode {
	return s.GetTokens(PCREParserBSlash)
}

func (s *QuotingContext) BSlash(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserBSlash, i)
}

func (s *QuotingContext) Qu() antlr.TerminalNode {
	return s.GetToken(PCREParserQu, 0)
}

func (s *QuotingContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *QuotingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuotingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterQuoting(s)
	}
}

func (s *QuotingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitQuoting(s)
	}
}

func (s *QuotingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitQuoting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Quoting() (localctx IQuotingContext) {
	localctx = NewQuotingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, PCREParserRULE_quoting)
	var _alt int

	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)
			p.Match(PCREParserQu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1+1 {
				p.SetState(629)
				p.MatchWildcard()

			}
			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		{
			p.SetState(635)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(636)
			p.Match(PCREParserEu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(637)
			p.Match(PCREParserBSlash)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(638)
		p.MatchWildcard()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDigitsContext is an interface to support dynamic dispatch.
type IDigitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDigit() []IDigitContext
	Digit(i int) IDigitContext

	// IsDigitsContext differentiates from other interfaces.
	IsDigitsContext()
}

type DigitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitsContext() *DigitsContext {
	var p = new(DigitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_digits
	return p
}

func InitEmptyDigitsContext(p *DigitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_digits
}

func (*DigitsContext) IsDigitsContext() {}

func NewDigitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitsContext {
	var p = new(DigitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digits

	return p
}

func (s *DigitsContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitsContext) AllDigit() []IDigitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDigitContext); ok {
			len++
		}
	}

	tst := make([]IDigitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDigitContext); ok {
			tst[i] = t.(IDigitContext)
			i++
		}
	}

	return tst
}

func (s *DigitsContext) Digit(i int) IDigitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *DigitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigits(s)
	}
}

func (s *DigitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigits(s)
	}
}

func (s *DigitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitDigits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Digits() (localctx IDigitsContext) {
	localctx = NewDigitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, PCREParserRULE_digits)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(641)
				p.Digit()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	D0() antlr.TerminalNode
	D1() antlr.TerminalNode
	D2() antlr.TerminalNode
	D3() antlr.TerminalNode
	D4() antlr.TerminalNode
	D5() antlr.TerminalNode
	D6() antlr.TerminalNode
	D7() antlr.TerminalNode
	D8() antlr.TerminalNode
	D9() antlr.TerminalNode

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_digit
	return p
}

func InitEmptyDigitContext(p *DigitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_digit
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitContext) D0() antlr.TerminalNode {
	return s.GetToken(PCREParserD0, 0)
}

func (s *DigitContext) D1() antlr.TerminalNode {
	return s.GetToken(PCREParserD1, 0)
}

func (s *DigitContext) D2() antlr.TerminalNode {
	return s.GetToken(PCREParserD2, 0)
}

func (s *DigitContext) D3() antlr.TerminalNode {
	return s.GetToken(PCREParserD3, 0)
}

func (s *DigitContext) D4() antlr.TerminalNode {
	return s.GetToken(PCREParserD4, 0)
}

func (s *DigitContext) D5() antlr.TerminalNode {
	return s.GetToken(PCREParserD5, 0)
}

func (s *DigitContext) D6() antlr.TerminalNode {
	return s.GetToken(PCREParserD6, 0)
}

func (s *DigitContext) D7() antlr.TerminalNode {
	return s.GetToken(PCREParserD7, 0)
}

func (s *DigitContext) D8() antlr.TerminalNode {
	return s.GetToken(PCREParserD8, 0)
}

func (s *DigitContext) D9() antlr.TerminalNode {
	return s.GetToken(PCREParserD9, 0)
}

func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (s *DigitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitDigit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Digit() (localctx IDigitContext) {
	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, PCREParserRULE_digit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-80)) & ^0x3f) == 0 && ((int64(1)<<(_la-80))&1023) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHexContext is an interface to support dynamic dispatch.
type IHexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Digit() IDigitContext
	Al() antlr.TerminalNode
	Bl() antlr.TerminalNode
	Cl() antlr.TerminalNode
	Dl() antlr.TerminalNode
	El() antlr.TerminalNode
	Fl() antlr.TerminalNode
	Au() antlr.TerminalNode
	Bu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Du() antlr.TerminalNode
	Eu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsHexContext differentiates from other interfaces.
	IsHexContext()
}

type HexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexContext() *HexContext {
	var p = new(HexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_hex
	return p
}

func InitEmptyHexContext(p *HexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_hex
}

func (*HexContext) IsHexContext() {}

func NewHexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexContext {
	var p = new(HexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_hex

	return p
}

func (s *HexContext) GetParser() antlr.Parser { return s.parser }

func (s *HexContext) Digit() IDigitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *HexContext) Al() antlr.TerminalNode {
	return s.GetToken(PCREParserAl, 0)
}

func (s *HexContext) Bl() antlr.TerminalNode {
	return s.GetToken(PCREParserBl, 0)
}

func (s *HexContext) Cl() antlr.TerminalNode {
	return s.GetToken(PCREParserCl, 0)
}

func (s *HexContext) Dl() antlr.TerminalNode {
	return s.GetToken(PCREParserDl, 0)
}

func (s *HexContext) El() antlr.TerminalNode {
	return s.GetToken(PCREParserEl, 0)
}

func (s *HexContext) Fl() antlr.TerminalNode {
	return s.GetToken(PCREParserFl, 0)
}

func (s *HexContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *HexContext) Bu() antlr.TerminalNode {
	return s.GetToken(PCREParserBu, 0)
}

func (s *HexContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *HexContext) Du() antlr.TerminalNode {
	return s.GetToken(PCREParserDu, 0)
}

func (s *HexContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *HexContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *HexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterHex(s)
	}
}

func (s *HexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitHex(s)
	}
}

func (s *HexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitHex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Hex() (localctx IHexContext) {
	localctx = NewHexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, PCREParserRULE_hex)
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(648)
			p.Digit()
		}

	case PCREParserAl:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(649)
			p.Match(PCREParserAl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserBl:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(650)
			p.Match(PCREParserBl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserCl:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(651)
			p.Match(PCREParserCl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserDl:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(652)
			p.Match(PCREParserDl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserEl:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(653)
			p.Match(PCREParserEl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserFl:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(654)
			p.Match(PCREParserFl)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserAu:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(655)
			p.Match(PCREParserAu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserBu:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(656)
			p.Match(PCREParserBu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserCu:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(657)
			p.Match(PCREParserCu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserDu:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(658)
			p.Match(PCREParserDu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserEu:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(659)
			p.Match(PCREParserEu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case PCREParserFu:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(660)
			p.Match(PCREParserFu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILettersContext is an interface to support dynamic dispatch.
type ILettersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetter() []ILetterContext
	Letter(i int) ILetterContext

	// IsLettersContext differentiates from other interfaces.
	IsLettersContext()
}

type LettersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLettersContext() *LettersContext {
	var p = new(LettersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_letters
	return p
}

func InitEmptyLettersContext(p *LettersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_letters
}

func (*LettersContext) IsLettersContext() {}

func NewLettersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LettersContext {
	var p = new(LettersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_letters

	return p
}

func (s *LettersContext) GetParser() antlr.Parser { return s.parser }

func (s *LettersContext) AllLetter() []ILetterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetterContext); ok {
			len++
		}
	}

	tst := make([]ILetterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetterContext); ok {
			tst[i] = t.(ILetterContext)
			i++
		}
	}

	return tst
}

func (s *LettersContext) Letter(i int) ILetterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *LettersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LettersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LettersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLetters(s)
	}
}

func (s *LettersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLetters(s)
	}
}

func (s *LettersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLetters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Letters() (localctx ILettersContext) {
	localctx = NewLettersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, PCREParserRULE_letters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-19)) & ^0x3f) == 0 && ((int64(1)<<(_la-19))&2305843009213693441) != 0) {
		{
			p.SetState(663)
			p.Letter()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetterContext is an interface to support dynamic dispatch.
type ILetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Al() antlr.TerminalNode
	Bl() antlr.TerminalNode
	Cl() antlr.TerminalNode
	Dl() antlr.TerminalNode
	El() antlr.TerminalNode
	Fl() antlr.TerminalNode
	Gl() antlr.TerminalNode
	Hl() antlr.TerminalNode
	Il() antlr.TerminalNode
	Jl() antlr.TerminalNode
	Kl() antlr.TerminalNode
	Ll() antlr.TerminalNode
	Ml() antlr.TerminalNode
	Nl() antlr.TerminalNode
	Ol() antlr.TerminalNode
	Pl() antlr.TerminalNode
	Ql() antlr.TerminalNode
	Rl() antlr.TerminalNode
	Sl() antlr.TerminalNode
	Tl() antlr.TerminalNode
	Ul() antlr.TerminalNode
	Vl() antlr.TerminalNode
	Wl() antlr.TerminalNode
	Xl() antlr.TerminalNode
	Yl() antlr.TerminalNode
	Zl() antlr.TerminalNode
	Au() antlr.TerminalNode
	Bu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Du() antlr.TerminalNode
	Eu() antlr.TerminalNode
	Fu() antlr.TerminalNode
	Gu() antlr.TerminalNode
	Hu() antlr.TerminalNode
	Iu() antlr.TerminalNode
	Ju() antlr.TerminalNode
	Ku() antlr.TerminalNode
	Lu() antlr.TerminalNode
	Mu() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Ou() antlr.TerminalNode
	Pu() antlr.TerminalNode
	Qu() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Su() antlr.TerminalNode
	Tu() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Vu() antlr.TerminalNode
	Wu() antlr.TerminalNode
	Xu() antlr.TerminalNode
	Yu() antlr.TerminalNode
	Zu() antlr.TerminalNode
	UScore() antlr.TerminalNode

	// IsLetterContext differentiates from other interfaces.
	IsLetterContext()
}

type LetterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetterContext() *LetterContext {
	var p = new(LetterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_letter
	return p
}

func InitEmptyLetterContext(p *LetterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_letter
}

func (*LetterContext) IsLetterContext() {}

func NewLetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetterContext {
	var p = new(LetterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_letter

	return p
}

func (s *LetterContext) GetParser() antlr.Parser { return s.parser }

func (s *LetterContext) Al() antlr.TerminalNode {
	return s.GetToken(PCREParserAl, 0)
}

func (s *LetterContext) Bl() antlr.TerminalNode {
	return s.GetToken(PCREParserBl, 0)
}

func (s *LetterContext) Cl() antlr.TerminalNode {
	return s.GetToken(PCREParserCl, 0)
}

func (s *LetterContext) Dl() antlr.TerminalNode {
	return s.GetToken(PCREParserDl, 0)
}

func (s *LetterContext) El() antlr.TerminalNode {
	return s.GetToken(PCREParserEl, 0)
}

func (s *LetterContext) Fl() antlr.TerminalNode {
	return s.GetToken(PCREParserFl, 0)
}

func (s *LetterContext) Gl() antlr.TerminalNode {
	return s.GetToken(PCREParserGl, 0)
}

func (s *LetterContext) Hl() antlr.TerminalNode {
	return s.GetToken(PCREParserHl, 0)
}

func (s *LetterContext) Il() antlr.TerminalNode {
	return s.GetToken(PCREParserIl, 0)
}

func (s *LetterContext) Jl() antlr.TerminalNode {
	return s.GetToken(PCREParserJl, 0)
}

func (s *LetterContext) Kl() antlr.TerminalNode {
	return s.GetToken(PCREParserKl, 0)
}

func (s *LetterContext) Ll() antlr.TerminalNode {
	return s.GetToken(PCREParserLl, 0)
}

func (s *LetterContext) Ml() antlr.TerminalNode {
	return s.GetToken(PCREParserMl, 0)
}

func (s *LetterContext) Nl() antlr.TerminalNode {
	return s.GetToken(PCREParserNl, 0)
}

func (s *LetterContext) Ol() antlr.TerminalNode {
	return s.GetToken(PCREParserOl, 0)
}

func (s *LetterContext) Pl() antlr.TerminalNode {
	return s.GetToken(PCREParserPl, 0)
}

func (s *LetterContext) Ql() antlr.TerminalNode {
	return s.GetToken(PCREParserQl, 0)
}

func (s *LetterContext) Rl() antlr.TerminalNode {
	return s.GetToken(PCREParserRl, 0)
}

func (s *LetterContext) Sl() antlr.TerminalNode {
	return s.GetToken(PCREParserSl, 0)
}

func (s *LetterContext) Tl() antlr.TerminalNode {
	return s.GetToken(PCREParserTl, 0)
}

func (s *LetterContext) Ul() antlr.TerminalNode {
	return s.GetToken(PCREParserUl, 0)
}

func (s *LetterContext) Vl() antlr.TerminalNode {
	return s.GetToken(PCREParserVl, 0)
}

func (s *LetterContext) Wl() antlr.TerminalNode {
	return s.GetToken(PCREParserWl, 0)
}

func (s *LetterContext) Xl() antlr.TerminalNode {
	return s.GetToken(PCREParserXl, 0)
}

func (s *LetterContext) Yl() antlr.TerminalNode {
	return s.GetToken(PCREParserYl, 0)
}

func (s *LetterContext) Zl() antlr.TerminalNode {
	return s.GetToken(PCREParserZl, 0)
}

func (s *LetterContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *LetterContext) Bu() antlr.TerminalNode {
	return s.GetToken(PCREParserBu, 0)
}

func (s *LetterContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *LetterContext) Du() antlr.TerminalNode {
	return s.GetToken(PCREParserDu, 0)
}

func (s *LetterContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *LetterContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *LetterContext) Gu() antlr.TerminalNode {
	return s.GetToken(PCREParserGu, 0)
}

func (s *LetterContext) Hu() antlr.TerminalNode {
	return s.GetToken(PCREParserHu, 0)
}

func (s *LetterContext) Iu() antlr.TerminalNode {
	return s.GetToken(PCREParserIu, 0)
}

func (s *LetterContext) Ju() antlr.TerminalNode {
	return s.GetToken(PCREParserJu, 0)
}

func (s *LetterContext) Ku() antlr.TerminalNode {
	return s.GetToken(PCREParserKu, 0)
}

func (s *LetterContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *LetterContext) Mu() antlr.TerminalNode {
	return s.GetToken(PCREParserMu, 0)
}

func (s *LetterContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *LetterContext) Ou() antlr.TerminalNode {
	return s.GetToken(PCREParserOu, 0)
}

func (s *LetterContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *LetterContext) Qu() antlr.TerminalNode {
	return s.GetToken(PCREParserQu, 0)
}

func (s *LetterContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *LetterContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *LetterContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *LetterContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *LetterContext) Vu() antlr.TerminalNode {
	return s.GetToken(PCREParserVu, 0)
}

func (s *LetterContext) Wu() antlr.TerminalNode {
	return s.GetToken(PCREParserWu, 0)
}

func (s *LetterContext) Xu() antlr.TerminalNode {
	return s.GetToken(PCREParserXu, 0)
}

func (s *LetterContext) Yu() antlr.TerminalNode {
	return s.GetToken(PCREParserYu, 0)
}

func (s *LetterContext) Zu() antlr.TerminalNode {
	return s.GetToken(PCREParserZu, 0)
}

func (s *LetterContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *LetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLetter(s)
	}
}

func (s *LetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLetter(s)
	}
}

func (s *LetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Letter() (localctx ILetterContext) {
	localctx = NewLetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, PCREParserRULE_letter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-19)) & ^0x3f) == 0 && ((int64(1)<<(_la-19))&2305843009213693441) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetter() []ILetterContext
	Letter(i int) ILetterContext
	AllDigit() []IDigitContext
	Digit(i int) IDigitContext

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_name
	return p
}

func InitEmptyNameContext(p *NameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_name
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) AllLetter() []ILetterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetterContext); ok {
			len++
		}
	}

	tst := make([]ILetterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetterContext); ok {
			tst[i] = t.(ILetterContext)
			i++
		}
	}

	return tst
}

func (s *NameContext) Letter(i int) ILetterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetterContext)
}

func (s *NameContext) AllDigit() []IDigitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDigitContext); ok {
			len++
		}
	}

	tst := make([]IDigitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDigitContext); ok {
			tst[i] = t.(IDigitContext)
			i++
		}
	}

	return tst
}

func (s *NameContext) Digit(i int) IDigitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDigitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitName(s)
	}
}

func (s *NameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, PCREParserRULE_name)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Letter()
	}
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-267911168) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&67108863) != 0) {
		p.SetState(673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case PCREParserUScore, PCREParserAu, PCREParserBu, PCREParserCu, PCREParserDu, PCREParserEu, PCREParserFu, PCREParserGu, PCREParserHu, PCREParserIu, PCREParserJu, PCREParserKu, PCREParserLu, PCREParserMu, PCREParserNu, PCREParserOu, PCREParserPu, PCREParserQu, PCREParserRu, PCREParserSu, PCREParserTu, PCREParserUu, PCREParserVu, PCREParserWu, PCREParserXu, PCREParserYu, PCREParserZu, PCREParserAl, PCREParserBl, PCREParserCl, PCREParserDl, PCREParserEl, PCREParserFl, PCREParserGl, PCREParserHl, PCREParserIl, PCREParserJl, PCREParserKl, PCREParserLl, PCREParserMl, PCREParserNl, PCREParserOl, PCREParserPl, PCREParserQl, PCREParserRl, PCREParserSl, PCREParserTl, PCREParserUl, PCREParserVl, PCREParserWl, PCREParserXl, PCREParserYl, PCREParserZl:
			{
				p.SetState(671)
				p.Letter()
			}

		case PCREParserD0, PCREParserD1, PCREParserD2, PCREParserD3, PCREParserD4, PCREParserD5, PCREParserD6, PCREParserD7, PCREParserD8, PCREParserD9:
			{
				p.SetState(672)
				p.Digit()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOtherContext is an interface to support dynamic dispatch.
type IOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CBrace() antlr.TerminalNode
	CBrack() antlr.TerminalNode
	Comma() antlr.TerminalNode
	Dash() antlr.TerminalNode
	UScore() antlr.TerminalNode
	Eq() antlr.TerminalNode
	Amp() antlr.TerminalNode
	Lt() antlr.TerminalNode
	Gt() antlr.TerminalNode
	Quote() antlr.TerminalNode
	Col() antlr.TerminalNode
	Hash() antlr.TerminalNode
	Excl() antlr.TerminalNode
	OTHER() antlr.TerminalNode

	// IsOtherContext differentiates from other interfaces.
	IsOtherContext()
}

type OtherContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOtherContext() *OtherContext {
	var p = new(OtherContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_other
	return p
}

func InitEmptyOtherContext(p *OtherContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_other
}

func (*OtherContext) IsOtherContext() {}

func NewOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherContext {
	var p = new(OtherContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_other

	return p
}

func (s *OtherContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherContext) CBrace() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrace, 0)
}

func (s *OtherContext) CBrack() antlr.TerminalNode {
	return s.GetToken(PCREParserCBrack, 0)
}

func (s *OtherContext) Comma() antlr.TerminalNode {
	return s.GetToken(PCREParserComma, 0)
}

func (s *OtherContext) Dash() antlr.TerminalNode {
	return s.GetToken(PCREParserDash, 0)
}

func (s *OtherContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *OtherContext) Eq() antlr.TerminalNode {
	return s.GetToken(PCREParserEq, 0)
}

func (s *OtherContext) Amp() antlr.TerminalNode {
	return s.GetToken(PCREParserAmp, 0)
}

func (s *OtherContext) Lt() antlr.TerminalNode {
	return s.GetToken(PCREParserLt, 0)
}

func (s *OtherContext) Gt() antlr.TerminalNode {
	return s.GetToken(PCREParserGt, 0)
}

func (s *OtherContext) Quote() antlr.TerminalNode {
	return s.GetToken(PCREParserQuote, 0)
}

func (s *OtherContext) Col() antlr.TerminalNode {
	return s.GetToken(PCREParserCol, 0)
}

func (s *OtherContext) Hash() antlr.TerminalNode {
	return s.GetToken(PCREParserHash, 0)
}

func (s *OtherContext) Excl() antlr.TerminalNode {
	return s.GetToken(PCREParserExcl, 0)
}

func (s *OtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(PCREParserOTHER, 0)
}

func (s *OtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterOther(s)
	}
}

func (s *OtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitOther(s)
	}
}

func (s *OtherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitOther(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Other() (localctx IOtherContext) {
	localctx = NewOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, PCREParserRULE_other)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&268322816) != 0) || _la == PCREParserOTHER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUtfContext is an interface to support dynamic dispatch.
type IUtfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uu() antlr.TerminalNode
	Tu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsUtfContext differentiates from other interfaces.
	IsUtfContext()
}

type UtfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtfContext() *UtfContext {
	var p = new(UtfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_utf
	return p
}

func InitEmptyUtfContext(p *UtfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_utf
}

func (*UtfContext) IsUtfContext() {}

func NewUtfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtfContext {
	var p = new(UtfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_utf

	return p
}

func (s *UtfContext) GetParser() antlr.Parser { return s.parser }

func (s *UtfContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *UtfContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *UtfContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *UtfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UtfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterUtf(s)
	}
}

func (s *UtfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitUtf(s)
	}
}

func (s *UtfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitUtf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Utf() (localctx IUtfContext) {
	localctx = NewUtfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, PCREParserRULE_utf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(682)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUcpContext is an interface to support dynamic dispatch.
type IUcpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Uu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Pu() antlr.TerminalNode

	// IsUcpContext differentiates from other interfaces.
	IsUcpContext()
}

type UcpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUcpContext() *UcpContext {
	var p = new(UcpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_ucp
	return p
}

func InitEmptyUcpContext(p *UcpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_ucp
}

func (*UcpContext) IsUcpContext() {}

func NewUcpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UcpContext {
	var p = new(UcpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_ucp

	return p
}

func (s *UcpContext) GetParser() antlr.Parser { return s.parser }

func (s *UcpContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *UcpContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *UcpContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *UcpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UcpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UcpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterUcp(s)
	}
}

func (s *UcpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitUcp(s)
	}
}

func (s *UcpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitUcp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Ucp() (localctx IUcpContext) {
	localctx = NewUcpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, PCREParserRULE_ucp)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(685)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(686)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INo_auto_possessContext is an interface to support dynamic dispatch.
type INo_auto_possessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Nu() antlr.TerminalNode
	AllOu() []antlr.TerminalNode
	Ou(i int) antlr.TerminalNode
	AllUScore() []antlr.TerminalNode
	UScore(i int) antlr.TerminalNode
	Au() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Tu() antlr.TerminalNode
	Pu() antlr.TerminalNode
	AllSu() []antlr.TerminalNode
	Su(i int) antlr.TerminalNode
	Eu() antlr.TerminalNode

	// IsNo_auto_possessContext differentiates from other interfaces.
	IsNo_auto_possessContext()
}

type No_auto_possessContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNo_auto_possessContext() *No_auto_possessContext {
	var p = new(No_auto_possessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_no_auto_possess
	return p
}

func InitEmptyNo_auto_possessContext(p *No_auto_possessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_no_auto_possess
}

func (*No_auto_possessContext) IsNo_auto_possessContext() {}

func NewNo_auto_possessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *No_auto_possessContext {
	var p = new(No_auto_possessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_no_auto_possess

	return p
}

func (s *No_auto_possessContext) GetParser() antlr.Parser { return s.parser }

func (s *No_auto_possessContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *No_auto_possessContext) AllOu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOu)
}

func (s *No_auto_possessContext) Ou(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOu, i)
}

func (s *No_auto_possessContext) AllUScore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUScore)
}

func (s *No_auto_possessContext) UScore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, i)
}

func (s *No_auto_possessContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *No_auto_possessContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *No_auto_possessContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *No_auto_possessContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *No_auto_possessContext) AllSu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserSu)
}

func (s *No_auto_possessContext) Su(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserSu, i)
}

func (s *No_auto_possessContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *No_auto_possessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *No_auto_possessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *No_auto_possessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNo_auto_possess(s)
	}
}

func (s *No_auto_possessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNo_auto_possess(s)
	}
}

func (s *No_auto_possessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNo_auto_possess(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) No_auto_possess() (localctx INo_auto_possessContext) {
	localctx = NewNo_auto_possessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, PCREParserRULE_no_auto_possess)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(689)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(690)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(691)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(692)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(693)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(694)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(695)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(696)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(697)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(701)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(702)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INo_start_optContext is an interface to support dynamic dispatch.
type INo_start_optContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Nu() antlr.TerminalNode
	AllOu() []antlr.TerminalNode
	Ou(i int) antlr.TerminalNode
	AllUScore() []antlr.TerminalNode
	UScore(i int) antlr.TerminalNode
	Su() antlr.TerminalNode
	AllTu() []antlr.TerminalNode
	Tu(i int) antlr.TerminalNode
	Au() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Pu() antlr.TerminalNode

	// IsNo_start_optContext differentiates from other interfaces.
	IsNo_start_optContext()
}

type No_start_optContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNo_start_optContext() *No_start_optContext {
	var p = new(No_start_optContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_no_start_opt
	return p
}

func InitEmptyNo_start_optContext(p *No_start_optContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_no_start_opt
}

func (*No_start_optContext) IsNo_start_optContext() {}

func NewNo_start_optContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *No_start_optContext {
	var p = new(No_start_optContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_no_start_opt

	return p
}

func (s *No_start_optContext) GetParser() antlr.Parser { return s.parser }

func (s *No_start_optContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *No_start_optContext) AllOu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserOu)
}

func (s *No_start_optContext) Ou(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserOu, i)
}

func (s *No_start_optContext) AllUScore() []antlr.TerminalNode {
	return s.GetTokens(PCREParserUScore)
}

func (s *No_start_optContext) UScore(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, i)
}

func (s *No_start_optContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *No_start_optContext) AllTu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserTu)
}

func (s *No_start_optContext) Tu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserTu, i)
}

func (s *No_start_optContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *No_start_optContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *No_start_optContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *No_start_optContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *No_start_optContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *No_start_optContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterNo_start_opt(s)
	}
}

func (s *No_start_optContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitNo_start_opt(s)
	}
}

func (s *No_start_optContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitNo_start_opt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) No_start_opt() (localctx INo_start_optContext) {
	localctx = NewNo_start_optContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, PCREParserRULE_no_start_opt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(705)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(706)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(707)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(708)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(710)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(711)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(712)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(713)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(714)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(715)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrContext is an interface to support dynamic dispatch.
type ICrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cu() antlr.TerminalNode
	Ru() antlr.TerminalNode

	// IsCrContext differentiates from other interfaces.
	IsCrContext()
}

type CrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrContext() *CrContext {
	var p = new(CrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_cr
	return p
}

func InitEmptyCrContext(p *CrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_cr
}

func (*CrContext) IsCrContext() {}

func NewCrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrContext {
	var p = new(CrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_cr

	return p
}

func (s *CrContext) GetParser() antlr.Parser { return s.parser }

func (s *CrContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *CrContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *CrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCr(s)
	}
}

func (s *CrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCr(s)
	}
}

func (s *CrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Cr() (localctx ICrContext) {
	localctx = NewCrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, PCREParserRULE_cr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(718)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILfContext is an interface to support dynamic dispatch.
type ILfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Lu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsLfContext differentiates from other interfaces.
	IsLfContext()
}

type LfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLfContext() *LfContext {
	var p = new(LfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_lf
	return p
}

func InitEmptyLfContext(p *LfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_lf
}

func (*LfContext) IsLfContext() {}

func NewLfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LfContext {
	var p = new(LfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_lf

	return p
}

func (s *LfContext) GetParser() antlr.Parser { return s.parser }

func (s *LfContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *LfContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *LfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLf(s)
	}
}

func (s *LfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLf(s)
	}
}

func (s *LfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Lf() (localctx ILfContext) {
	localctx = NewLfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, PCREParserRULE_lf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(721)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cu() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Lu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_crlf
	return p
}

func InitEmptyCrlfContext(p *CrlfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_crlf
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *CrlfContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *CrlfContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *CrlfContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (s *CrlfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCrlf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Crlf() (localctx ICrlfContext) {
	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, PCREParserRULE_crlf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(723)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(724)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(725)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(726)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnycrlfContext is an interface to support dynamic dispatch.
type IAnycrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Au() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Yu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Lu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsAnycrlfContext differentiates from other interfaces.
	IsAnycrlfContext()
}

type AnycrlfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnycrlfContext() *AnycrlfContext {
	var p = new(AnycrlfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_anycrlf
	return p
}

func InitEmptyAnycrlfContext(p *AnycrlfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_anycrlf
}

func (*AnycrlfContext) IsAnycrlfContext() {}

func NewAnycrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnycrlfContext {
	var p = new(AnycrlfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_anycrlf

	return p
}

func (s *AnycrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *AnycrlfContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *AnycrlfContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *AnycrlfContext) Yu() antlr.TerminalNode {
	return s.GetToken(PCREParserYu, 0)
}

func (s *AnycrlfContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *AnycrlfContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *AnycrlfContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *AnycrlfContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *AnycrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnycrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnycrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAnycrlf(s)
	}
}

func (s *AnycrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAnycrlf(s)
	}
}

func (s *AnycrlfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAnycrlf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Anycrlf() (localctx IAnycrlfContext) {
	localctx = NewAnycrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, PCREParserRULE_anycrlf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(729)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(730)
		p.Match(PCREParserYu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(731)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(732)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(733)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(734)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnyContext is an interface to support dynamic dispatch.
type IAnyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Au() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Yu() antlr.TerminalNode

	// IsAnyContext differentiates from other interfaces.
	IsAnyContext()
}

type AnyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnyContext() *AnyContext {
	var p = new(AnyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_any
	return p
}

func InitEmptyAnyContext(p *AnyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_any
}

func (*AnyContext) IsAnyContext() {}

func NewAnyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnyContext {
	var p = new(AnyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_any

	return p
}

func (s *AnyContext) GetParser() antlr.Parser { return s.parser }

func (s *AnyContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *AnyContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *AnyContext) Yu() antlr.TerminalNode {
	return s.GetToken(PCREParserYu, 0)
}

func (s *AnyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAny(s)
	}
}

func (s *AnyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAny(s)
	}
}

func (s *AnyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAny(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Any() (localctx IAnyContext) {
	localctx = NewAnyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, PCREParserRULE_any)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(737)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(738)
		p.Match(PCREParserYu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_matchContext is an interface to support dynamic dispatch.
type ILimit_matchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Lu() antlr.TerminalNode
	AllIu() []antlr.TerminalNode
	Iu(i int) antlr.TerminalNode
	AllMu() []antlr.TerminalNode
	Mu(i int) antlr.TerminalNode
	AllTu() []antlr.TerminalNode
	Tu(i int) antlr.TerminalNode
	UScore() antlr.TerminalNode
	Au() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Hu() antlr.TerminalNode

	// IsLimit_matchContext differentiates from other interfaces.
	IsLimit_matchContext()
}

type Limit_matchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_matchContext() *Limit_matchContext {
	var p = new(Limit_matchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_limit_match
	return p
}

func InitEmptyLimit_matchContext(p *Limit_matchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_limit_match
}

func (*Limit_matchContext) IsLimit_matchContext() {}

func NewLimit_matchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_matchContext {
	var p = new(Limit_matchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_limit_match

	return p
}

func (s *Limit_matchContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_matchContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *Limit_matchContext) AllIu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserIu)
}

func (s *Limit_matchContext) Iu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserIu, i)
}

func (s *Limit_matchContext) AllMu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserMu)
}

func (s *Limit_matchContext) Mu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserMu, i)
}

func (s *Limit_matchContext) AllTu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserTu)
}

func (s *Limit_matchContext) Tu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserTu, i)
}

func (s *Limit_matchContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *Limit_matchContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *Limit_matchContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *Limit_matchContext) Hu() antlr.TerminalNode {
	return s.GetToken(PCREParserHu, 0)
}

func (s *Limit_matchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_matchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_matchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLimit_match(s)
	}
}

func (s *Limit_matchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLimit_match(s)
	}
}

func (s *Limit_matchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLimit_match(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Limit_match() (localctx ILimit_matchContext) {
	localctx = NewLimit_matchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, PCREParserRULE_limit_match)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(741)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(742)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(743)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(744)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(745)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(746)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(747)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(748)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(749)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(750)
		p.Match(PCREParserHu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimit_recursionContext is an interface to support dynamic dispatch.
type ILimit_recursionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Lu() antlr.TerminalNode
	AllIu() []antlr.TerminalNode
	Iu(i int) antlr.TerminalNode
	Mu() antlr.TerminalNode
	Tu() antlr.TerminalNode
	UScore() antlr.TerminalNode
	AllRu() []antlr.TerminalNode
	Ru(i int) antlr.TerminalNode
	Eu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Su() antlr.TerminalNode
	Ou() antlr.TerminalNode
	Nu() antlr.TerminalNode

	// IsLimit_recursionContext differentiates from other interfaces.
	IsLimit_recursionContext()
}

type Limit_recursionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimit_recursionContext() *Limit_recursionContext {
	var p = new(Limit_recursionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_limit_recursion
	return p
}

func InitEmptyLimit_recursionContext(p *Limit_recursionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_limit_recursion
}

func (*Limit_recursionContext) IsLimit_recursionContext() {}

func NewLimit_recursionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Limit_recursionContext {
	var p = new(Limit_recursionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_limit_recursion

	return p
}

func (s *Limit_recursionContext) GetParser() antlr.Parser { return s.parser }

func (s *Limit_recursionContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *Limit_recursionContext) AllIu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserIu)
}

func (s *Limit_recursionContext) Iu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserIu, i)
}

func (s *Limit_recursionContext) Mu() antlr.TerminalNode {
	return s.GetToken(PCREParserMu, 0)
}

func (s *Limit_recursionContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *Limit_recursionContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *Limit_recursionContext) AllRu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserRu)
}

func (s *Limit_recursionContext) Ru(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserRu, i)
}

func (s *Limit_recursionContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *Limit_recursionContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *Limit_recursionContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *Limit_recursionContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *Limit_recursionContext) Ou() antlr.TerminalNode {
	return s.GetToken(PCREParserOu, 0)
}

func (s *Limit_recursionContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *Limit_recursionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Limit_recursionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Limit_recursionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterLimit_recursion(s)
	}
}

func (s *Limit_recursionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitLimit_recursion(s)
	}
}

func (s *Limit_recursionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitLimit_recursion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Limit_recursion() (localctx ILimit_recursionContext) {
	localctx = NewLimit_recursionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, PCREParserRULE_limit_recursion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(752)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(753)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(754)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(755)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(756)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(757)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(758)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(759)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(760)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(761)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(762)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(763)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(765)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(766)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBsr_anycrlfContext is an interface to support dynamic dispatch.
type IBsr_anycrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bu() antlr.TerminalNode
	Su() antlr.TerminalNode
	AllRu() []antlr.TerminalNode
	Ru(i int) antlr.TerminalNode
	UScore() antlr.TerminalNode
	Au() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Yu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Lu() antlr.TerminalNode
	Fu() antlr.TerminalNode

	// IsBsr_anycrlfContext differentiates from other interfaces.
	IsBsr_anycrlfContext()
}

type Bsr_anycrlfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBsr_anycrlfContext() *Bsr_anycrlfContext {
	var p = new(Bsr_anycrlfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_bsr_anycrlf
	return p
}

func InitEmptyBsr_anycrlfContext(p *Bsr_anycrlfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_bsr_anycrlf
}

func (*Bsr_anycrlfContext) IsBsr_anycrlfContext() {}

func NewBsr_anycrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bsr_anycrlfContext {
	var p = new(Bsr_anycrlfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_bsr_anycrlf

	return p
}

func (s *Bsr_anycrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *Bsr_anycrlfContext) Bu() antlr.TerminalNode {
	return s.GetToken(PCREParserBu, 0)
}

func (s *Bsr_anycrlfContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *Bsr_anycrlfContext) AllRu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserRu)
}

func (s *Bsr_anycrlfContext) Ru(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserRu, i)
}

func (s *Bsr_anycrlfContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *Bsr_anycrlfContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *Bsr_anycrlfContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *Bsr_anycrlfContext) Yu() antlr.TerminalNode {
	return s.GetToken(PCREParserYu, 0)
}

func (s *Bsr_anycrlfContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *Bsr_anycrlfContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *Bsr_anycrlfContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *Bsr_anycrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bsr_anycrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bsr_anycrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBsr_anycrlf(s)
	}
}

func (s *Bsr_anycrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBsr_anycrlf(s)
	}
}

func (s *Bsr_anycrlfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBsr_anycrlf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Bsr_anycrlf() (localctx IBsr_anycrlfContext) {
	localctx = NewBsr_anycrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, PCREParserRULE_bsr_anycrlf)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.Match(PCREParserBu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(769)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(770)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(772)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(774)
		p.Match(PCREParserYu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(775)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(776)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(777)
		p.Match(PCREParserLu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(778)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBsr_unicodeContext is an interface to support dynamic dispatch.
type IBsr_unicodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Bu() antlr.TerminalNode
	Su() antlr.TerminalNode
	Ru() antlr.TerminalNode
	UScore() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Iu() antlr.TerminalNode
	Cu() antlr.TerminalNode
	Ou() antlr.TerminalNode
	Du() antlr.TerminalNode
	Eu() antlr.TerminalNode

	// IsBsr_unicodeContext differentiates from other interfaces.
	IsBsr_unicodeContext()
}

type Bsr_unicodeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBsr_unicodeContext() *Bsr_unicodeContext {
	var p = new(Bsr_unicodeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_bsr_unicode
	return p
}

func InitEmptyBsr_unicodeContext(p *Bsr_unicodeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_bsr_unicode
}

func (*Bsr_unicodeContext) IsBsr_unicodeContext() {}

func NewBsr_unicodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Bsr_unicodeContext {
	var p = new(Bsr_unicodeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_bsr_unicode

	return p
}

func (s *Bsr_unicodeContext) GetParser() antlr.Parser { return s.parser }

func (s *Bsr_unicodeContext) Bu() antlr.TerminalNode {
	return s.GetToken(PCREParserBu, 0)
}

func (s *Bsr_unicodeContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *Bsr_unicodeContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *Bsr_unicodeContext) UScore() antlr.TerminalNode {
	return s.GetToken(PCREParserUScore, 0)
}

func (s *Bsr_unicodeContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *Bsr_unicodeContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *Bsr_unicodeContext) Iu() antlr.TerminalNode {
	return s.GetToken(PCREParserIu, 0)
}

func (s *Bsr_unicodeContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *Bsr_unicodeContext) Ou() antlr.TerminalNode {
	return s.GetToken(PCREParserOu, 0)
}

func (s *Bsr_unicodeContext) Du() antlr.TerminalNode {
	return s.GetToken(PCREParserDu, 0)
}

func (s *Bsr_unicodeContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *Bsr_unicodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Bsr_unicodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Bsr_unicodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterBsr_unicode(s)
	}
}

func (s *Bsr_unicodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitBsr_unicode(s)
	}
}

func (s *Bsr_unicodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitBsr_unicode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Bsr_unicode() (localctx IBsr_unicodeContext) {
	localctx = NewBsr_unicodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, PCREParserRULE_bsr_unicode)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(PCREParserBu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(782)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(783)
		p.Match(PCREParserUScore)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(784)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(785)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(786)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(788)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(789)
		p.Match(PCREParserDu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(790)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccept_Context is an interface to support dynamic dispatch.
type IAccept_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Au() antlr.TerminalNode
	AllCu() []antlr.TerminalNode
	Cu(i int) antlr.TerminalNode
	Eu() antlr.TerminalNode
	Pu() antlr.TerminalNode
	Tu() antlr.TerminalNode

	// IsAccept_Context differentiates from other interfaces.
	IsAccept_Context()
}

type Accept_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccept_Context() *Accept_Context {
	var p = new(Accept_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_accept_
	return p
}

func InitEmptyAccept_Context(p *Accept_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_accept_
}

func (*Accept_Context) IsAccept_Context() {}

func NewAccept_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Accept_Context {
	var p = new(Accept_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_accept_

	return p
}

func (s *Accept_Context) GetParser() antlr.Parser { return s.parser }

func (s *Accept_Context) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *Accept_Context) AllCu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserCu)
}

func (s *Accept_Context) Cu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserCu, i)
}

func (s *Accept_Context) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *Accept_Context) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *Accept_Context) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *Accept_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Accept_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Accept_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterAccept_(s)
	}
}

func (s *Accept_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitAccept_(s)
	}
}

func (s *Accept_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitAccept_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Accept_() (localctx IAccept_Context) {
	localctx = NewAccept_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, PCREParserRULE_accept_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(793)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(794)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(795)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(796)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(797)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFailContext is an interface to support dynamic dispatch.
type IFailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Fu() antlr.TerminalNode
	Au() antlr.TerminalNode
	Iu() antlr.TerminalNode
	Lu() antlr.TerminalNode

	// IsFailContext differentiates from other interfaces.
	IsFailContext()
}

type FailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFailContext() *FailContext {
	var p = new(FailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_fail
	return p
}

func InitEmptyFailContext(p *FailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_fail
}

func (*FailContext) IsFailContext() {}

func NewFailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FailContext {
	var p = new(FailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_fail

	return p
}

func (s *FailContext) GetParser() antlr.Parser { return s.parser }

func (s *FailContext) Fu() antlr.TerminalNode {
	return s.GetToken(PCREParserFu, 0)
}

func (s *FailContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *FailContext) Iu() antlr.TerminalNode {
	return s.GetToken(PCREParserIu, 0)
}

func (s *FailContext) Lu() antlr.TerminalNode {
	return s.GetToken(PCREParserLu, 0)
}

func (s *FailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterFail(s)
	}
}

func (s *FailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitFail(s)
	}
}

func (s *FailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitFail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Fail() (localctx IFailContext) {
	localctx = NewFailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, PCREParserRULE_fail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.Match(PCREParserFu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(803)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == PCREParserAu {
		{
			p.SetState(800)
			p.Match(PCREParserAu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.Match(PCREParserIu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(802)
			p.Match(PCREParserLu)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMarkContext is an interface to support dynamic dispatch.
type IMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Mu() antlr.TerminalNode
	Au() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Ku() antlr.TerminalNode

	// IsMarkContext differentiates from other interfaces.
	IsMarkContext()
}

type MarkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMarkContext() *MarkContext {
	var p = new(MarkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_mark
	return p
}

func InitEmptyMarkContext(p *MarkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_mark
}

func (*MarkContext) IsMarkContext() {}

func NewMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MarkContext {
	var p = new(MarkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_mark

	return p
}

func (s *MarkContext) GetParser() antlr.Parser { return s.parser }

func (s *MarkContext) Mu() antlr.TerminalNode {
	return s.GetToken(PCREParserMu, 0)
}

func (s *MarkContext) Au() antlr.TerminalNode {
	return s.GetToken(PCREParserAu, 0)
}

func (s *MarkContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *MarkContext) Ku() antlr.TerminalNode {
	return s.GetToken(PCREParserKu, 0)
}

func (s *MarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterMark(s)
	}
}

func (s *MarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitMark(s)
	}
}

func (s *MarkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitMark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Mark() (localctx IMarkContext) {
	localctx = NewMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, PCREParserRULE_mark)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(806)
		p.Match(PCREParserAu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(807)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(808)
		p.Match(PCREParserKu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitContext is an interface to support dynamic dispatch.
type ICommitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Cu() antlr.TerminalNode
	Ou() antlr.TerminalNode
	AllMu() []antlr.TerminalNode
	Mu(i int) antlr.TerminalNode
	Iu() antlr.TerminalNode
	Tu() antlr.TerminalNode

	// IsCommitContext differentiates from other interfaces.
	IsCommitContext()
}

type CommitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitContext() *CommitContext {
	var p = new(CommitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_commit
	return p
}

func InitEmptyCommitContext(p *CommitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_commit
}

func (*CommitContext) IsCommitContext() {}

func NewCommitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitContext {
	var p = new(CommitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_commit

	return p
}

func (s *CommitContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitContext) Cu() antlr.TerminalNode {
	return s.GetToken(PCREParserCu, 0)
}

func (s *CommitContext) Ou() antlr.TerminalNode {
	return s.GetToken(PCREParserOu, 0)
}

func (s *CommitContext) AllMu() []antlr.TerminalNode {
	return s.GetTokens(PCREParserMu)
}

func (s *CommitContext) Mu(i int) antlr.TerminalNode {
	return s.GetToken(PCREParserMu, i)
}

func (s *CommitContext) Iu() antlr.TerminalNode {
	return s.GetToken(PCREParserIu, 0)
}

func (s *CommitContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *CommitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterCommit(s)
	}
}

func (s *CommitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitCommit(s)
	}
}

func (s *CommitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitCommit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Commit() (localctx ICommitContext) {
	localctx = NewCommitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, PCREParserRULE_commit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.Match(PCREParserCu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(811)
		p.Match(PCREParserOu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(812)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(813)
		p.Match(PCREParserMu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(814)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(815)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPruneContext is an interface to support dynamic dispatch.
type IPruneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pu() antlr.TerminalNode
	Ru() antlr.TerminalNode
	Uu() antlr.TerminalNode
	Nu() antlr.TerminalNode
	Eu() antlr.TerminalNode

	// IsPruneContext differentiates from other interfaces.
	IsPruneContext()
}

type PruneContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPruneContext() *PruneContext {
	var p = new(PruneContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_prune
	return p
}

func InitEmptyPruneContext(p *PruneContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_prune
}

func (*PruneContext) IsPruneContext() {}

func NewPruneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PruneContext {
	var p = new(PruneContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_prune

	return p
}

func (s *PruneContext) GetParser() antlr.Parser { return s.parser }

func (s *PruneContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *PruneContext) Ru() antlr.TerminalNode {
	return s.GetToken(PCREParserRu, 0)
}

func (s *PruneContext) Uu() antlr.TerminalNode {
	return s.GetToken(PCREParserUu, 0)
}

func (s *PruneContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *PruneContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *PruneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PruneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PruneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterPrune(s)
	}
}

func (s *PruneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitPrune(s)
	}
}

func (s *PruneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitPrune(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Prune() (localctx IPruneContext) {
	localctx = NewPruneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, PCREParserRULE_prune)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(818)
		p.Match(PCREParserRu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(819)
		p.Match(PCREParserUu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(820)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(821)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISkipContext is an interface to support dynamic dispatch.
type ISkipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Su() antlr.TerminalNode
	Ku() antlr.TerminalNode
	Iu() antlr.TerminalNode
	Pu() antlr.TerminalNode

	// IsSkipContext differentiates from other interfaces.
	IsSkipContext()
}

type SkipContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySkipContext() *SkipContext {
	var p = new(SkipContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_skip
	return p
}

func InitEmptySkipContext(p *SkipContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_skip
}

func (*SkipContext) IsSkipContext() {}

func NewSkipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SkipContext {
	var p = new(SkipContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_skip

	return p
}

func (s *SkipContext) GetParser() antlr.Parser { return s.parser }

func (s *SkipContext) Su() antlr.TerminalNode {
	return s.GetToken(PCREParserSu, 0)
}

func (s *SkipContext) Ku() antlr.TerminalNode {
	return s.GetToken(PCREParserKu, 0)
}

func (s *SkipContext) Iu() antlr.TerminalNode {
	return s.GetToken(PCREParserIu, 0)
}

func (s *SkipContext) Pu() antlr.TerminalNode {
	return s.GetToken(PCREParserPu, 0)
}

func (s *SkipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SkipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SkipContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterSkip(s)
	}
}

func (s *SkipContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitSkip(s)
	}
}

func (s *SkipContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitSkip(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Skip() (localctx ISkipContext) {
	localctx = NewSkipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, PCREParserRULE_skip)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(PCREParserSu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(824)
		p.Match(PCREParserKu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(825)
		p.Match(PCREParserIu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(826)
		p.Match(PCREParserPu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThenContext is an interface to support dynamic dispatch.
type IThenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tu() antlr.TerminalNode
	Hu() antlr.TerminalNode
	Eu() antlr.TerminalNode
	Nu() antlr.TerminalNode

	// IsThenContext differentiates from other interfaces.
	IsThenContext()
}

type ThenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThenContext() *ThenContext {
	var p = new(ThenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_then
	return p
}

func InitEmptyThenContext(p *ThenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = PCREParserRULE_then
}

func (*ThenContext) IsThenContext() {}

func NewThenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThenContext {
	var p = new(ThenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = PCREParserRULE_then

	return p
}

func (s *ThenContext) GetParser() antlr.Parser { return s.parser }

func (s *ThenContext) Tu() antlr.TerminalNode {
	return s.GetToken(PCREParserTu, 0)
}

func (s *ThenContext) Hu() antlr.TerminalNode {
	return s.GetToken(PCREParserHu, 0)
}

func (s *ThenContext) Eu() antlr.TerminalNode {
	return s.GetToken(PCREParserEu, 0)
}

func (s *ThenContext) Nu() antlr.TerminalNode {
	return s.GetToken(PCREParserNu, 0)
}

func (s *ThenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.EnterThen(s)
	}
}

func (s *ThenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(PCREListener); ok {
		listenerT.ExitThen(s)
	}
}

func (s *ThenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case PCREVisitor:
		return t.VisitThen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *PCREParser) Then() (localctx IThenContext) {
	localctx = NewThenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, PCREParserRULE_then)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(828)
		p.Match(PCREParserTu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(829)
		p.Match(PCREParserHu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(830)
		p.Match(PCREParserEu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(831)
		p.Match(PCREParserNu)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
